# 原创
：  深度优先搜索(DFS)-蓝桥杯

# 深度优先搜索(DFS)-蓝桥杯

## 一、搜索

## 二、暴力法
1. 理论上，蛮力法可以解决可计算领域的各种问题。1. 蛮力法经常用来解决一些较小规模的问题。1. 对于一些重要的问题蛮力法可以产生一些合理的算法具备一些实用价值，而且不受问题规模的限制。1. 蛮力法可以作为某类问题时间性能的底限，来衡量同样问题的更高效算法。1. 蛮力的基本方法——扫描。1. 关键——依次处理所有元素。1. 基本的扫描技术——遍历：1. 集合的遍历。1. 线性表的遍历1. 树的遍历1. 图的遍历
## 三、老鼠走迷宫
1. <h3>BFS：一群老鼠走迷宫</h3>
```
• 老鼠无限多。
• 在每个路口，都派出部分老鼠探索所有没走过的路。
• 走某条路的老鼠，如果碰壁无法前行，就停下。
• 如果到达的路口已经有别的老鼠探索过了，也停下。
• 所有的道路都会走到，而且不会重复。

------&gt;广度优先、全面扩散、逐层递进。
```
1. <h3>DFS：一只老鼠走迷宫</h3>
```
• 只有一只老鼠。
• 在每个路口，都选择先走右边 (当然，选择先走左边也可以)，能走多远就走多远。
• 碰壁无法再继续往前走，回退一步，这一次走左边然后继续往下走。
• 能走遍所有的路，而且不会重复 (回退不算重复)。

------&gt;深度优先、一路到底、逐层回退。
```

## 四、DFS访问示例

## 五、DFS的常见操作

## 六、DFS基础：递归和记忆化搜索

## 七、例子：斐波那契数列

```
递推式: f(n) = f(n-1) + f(n-2)
即：前两个数相加得到下一个数。
要求：打印第20个数。
```
1. <h3>普通方法实现</h3>1. <h3>递归方法实现</h3>
递归前进: fib(20) = fib(19) + fib(18)

递归前进: fib(19) = fib(18) + fib(17)

递归前进: fib(18) = fib(17) + fib(16)

 ......

递归前进: fib(3) = fib(2) + fib(1)

到达终止条件: fib(2) = 1，fib(1) = 1

递归返回： fib(3) = fib(2) + fib(1) =1+1=2

递归返回： fib(4) = fib(3) + fib(2) =2+1=3

 ......

递归返回： fib(20)=fib(19)+fib(18)=4181+2584=6765

递推和递归两种代码，结果一样，计算量差别巨大。

递推代码:一个for循环，计算20次。

递归代码: 计算第20个斐波那契数，共计算cnt = 13529次。

return fib(n-1) + fib(n-2)递归调用了自己2次，倍增。

计算fib(n)时，共执行了O(2的n次方)次递归。

不过，很多递归函数只调用自己一次不个额外增加计算量。
1. <h3>改进：记忆法</h3>
Python默认递归深度1000，如果递归深度太大,提示“maximum recursion depth exceeded in comparison”。

用sys.setrecursionlimit()设置递归深度。

常常有深度大于1000的递归题目。

## 八、DFS的代码框架

## 九、例子：DFS搜索和输出所有路径

## 十、总结：路径问题BFS和DFS
