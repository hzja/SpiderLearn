# 原创
：  【web-攻击逻辑设计缺陷】(8.3)设计缺陷：虚假数量折扣、输入转义、转义、截短功能

# 【web-攻击逻辑设计缺陷】(8.3)设计缺陷：虚假数量折扣、输入转义、转义、截短功能

**目录**

[一、逻辑设计缺陷示例](#%E4%B8%80%E3%80%81%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E7%A4%BA%E4%BE%8B)

[示例7：虚假数量折扣](#2.1%E3%80%81%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%BE%81%E6%B1%82%E5%8A%9F%E8%83%BD)

[说明：](#%E8%AF%B4%E6%98%8E%EF%BC%9A)

[设计：](#%E8%AE%BE%E8%AE%A1%EF%BC%9A)

[攻击：](#%E6%94%BB%E5%87%BB%EF%BC%9A)

[过程：](#%E8%BF%87%E7%A8%8B%EF%BC%9A)

[示例8：输入转义](#2.1%E3%80%81%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%BE%81%E6%B1%82%E5%8A%9F%E8%83%BD)

[说明：](#%E8%AF%B4%E6%98%8E%EF%BC%9A)

[设计：](#%E8%AE%BE%E8%AE%A1%EF%BC%9A)

[攻击：](#%E6%94%BB%E5%87%BB%EF%BC%9A)

[过程：](#%E8%BF%87%E7%A8%8B%EF%BC%9A)

[示例9：转义、截短功能](#2.1%E3%80%81%E7%A4%BA%E4%BE%8B1%EF%BC%9A%E5%BE%81%E6%B1%82%E5%8A%9F%E8%83%BD)

[说明：](#%E8%AF%B4%E6%98%8E%EF%BC%9A)

[设计：](#%E8%AE%BE%E8%AE%A1%EF%BC%9A)

[攻击：](#%E6%94%BB%E5%87%BB%EF%BC%9A)

[过程：](#%E8%BF%87%E7%A8%8B%EF%BC%9A)

---


## 一、逻辑设计缺陷示例

> 
<h3>示例7：虚假数量折扣</h3>
<h4>说明：</h4>
应用程序允许用户订购产品，如果购买的产品达到一定数量，就有资格获得大幅折扣，例如如果用户分别购买了3件衣服，就可以获得75％的折扣。
<hr/>
<h4>设计：</h4>
当用户在购物车中增加一件商品时， 应用程序就使用各种规则决定他购买的产品是否有资格获得折扣，如果用户可以获得折扣，应用程序就根据折扣率调整购物车中的商品价格。开发者认为用户只有购买捆绑销售的商品才能获得折扣
<hr/>
<h4>攻击：</h4>
设计可能存在的缺陷：如果设计忽略用户向购物车中添加商品后可能会再将其从中移走，可能会往购物车中添加供应商出售的大量产品， 以获得最大可能的折扣，当购物车中的商品可以采用折扣时，他就会把不需要的商品从中取走，而购物车中剩下的商品仍然可以享受原来的折扣（其实更多的是修改数量、价格、优惠额度）
<hr/>
<h4>过程：</h4>
1、如果有任何价格或其他敏感价值需要根据用户控制的数据或操作确定的标准进行调整，了解应用程序使用的算法以及需要调整的逻辑，确定这些调整是一次性行为， 还是需要根据用户执行的其他操作进行修改
2、努力想出操纵应用程序行为的办法， 使应用程序进行的调整与开发者最初设定的标准相互矛盾


#### 设计：

---


#### 过程：

> 
<h3>示例8：输入转义</h3>
<h4>说明：</h4>
应用程序决定执行某种功能， 该功能需要以自变量的形式向操作系统命令提交用户控制的输入。应用程序的开发者知道这种橾作包含着内在的风险，并决定净化用户输入中出现的任何潜在的恶意字符， 从而防御这种风险。特殊字符都需要使用反斜线（\）进行转义; ` | : &amp; &lt; &gt; 空格 换行符
以这种方式进行转义后，shell命令解释器就把它们当做提交给被调用命令的自变量的一部分， 而非shell元字符。后者可用于注入其他命令或自变量、重定向输出等
<hr/>
<h4>设计：</h4>
设计的方法可有效防御命令注入攻击，考虑到了每一个可能被攻击者利用的字符，并对它们进行了适当的转义处理，不会造成风险
<hr/>
<h4>攻击：</h4>
开发者忘记对转义字符本身进行转义，攻击者在利用简单的命令注入漏洞时并不直接使用反斜线，因此开发者认为它并非恶意字符，正是由于没有对它进行转义， 攻击者就可以完全破坏应用程序的净化机制。假设攻击者向易受攻击的功能提交：foo\;ls   转义处理后变为：foo\\;ls
当这个数据作为自变量提交给操作系统命令时， shell解释器把第一个反斜线作为转义字符，而把第二个反斜线当做自变量反斜线处理，反斜线不是一个转义字符， 而是自变量的一部分，它遇到分号，该字符明显没有进行转义，斛释器把分号作为一个命令分隔符， 因此继续执行攻击者注入的命令
<hr/>
<h4>过程：</h4>
尝试在受控制的数据中数人相关元字符后，并在每个元字符前插入一个反斜线， 测试前面描述的逻辑缺陷


#### 设计：

---


#### 过程：

> 
<h3>示例9：转义、截短功能</h3>
<h4>说明：</h4>
该应用程序包含一组输入确认程序， 以防范各种类型的攻击。其中的两种防御机制为SQL注入过滤和长度限制
应用程序对在基于字符串的用户输入中出现的任何单引号进行转义（并拒绝在数字输入中出现的任何单引号），以防范SQL注入。两个单引号在一起将构成一个转义序列，表示一个原义单引号，数据库会将其解释为引用字符串中的数据，而不是结束字符串的终止符。许多开发者认为通过将用户提交的输入中的任何单引号配对，就可以防止SQL注入攻击
长度限制适用于所有输入， 确保用户提交的变量不会超过128个字符。如果任何变量超过128<br/> 个字符，将其截短
<hr/>
<h4>设计：</h4>
采用SQL注入过滤和长度限制的防御机制
<hr/>
<h4>攻击：</h4>
SQL注入防御通过将用户输入中的任何引号配对而生效，因此在每对引号中，第一个引号将作为第二个引号的转义字符。如果开发者并没有考虑周全，将经过转义的输入提交给“截短” 功能
假设应用程序将用户输入中的任何单引号配对， 然后对该数据实施长度限制， 将其截短为128个字符。
admin'--+已经不行了(假设存在注入点)
使用127个a加上单引号（aa……aa'），应用程序会首先将单引号配对，然后将字符串截短为128个字符， 导致输入又恢复其原始值。这时会生成数据库错误， 因为在查询中注入了另外一个单引号， 而没有纠正周围的语法。此时输入密码or 1=1--+将变为
select * from users where username='aa……a' 'and password = 'or 1=1 --+'
' '将被解释为转义引号， 因而被作为查询数据的一部分
此时数据库认为用户输入的用户名为aa……a ' and password =
<hr/>
<h4>过程：</h4>
记下应用程序修改用户输入（截短、删除数据、编码或解码）的任何位置。对于每一个位置， 确定是否可以人为构造恶意字符串
1、如果数据已被过滤一次（非递归）， 确定是否可以提交一个“补偿“ 过滤操作的字符串。如果应用程序过滤select这个SQL关键字， 则可以提交selselectect，看过滤机制是否会删除其中的select子字符串， 而留下select
2、如果数据确认按设定的顺序发生，且有一个或多个确认步骤修改了数据，则确定是否可以将这些步骤用于破坏之前的确认步骤。例如如果应用程序执行URL编码，然后过滤掉恶意数据（如&lt;script&gt;标签），则可以通过提交字符串来避开确认机制
%&lt;script&gt;3cscript%&lt;script&gt;3ealert(1)%&lt;script&gt;3c/
script%&lt;script&gt;3e


#### 设计：

---


#### 过程：
