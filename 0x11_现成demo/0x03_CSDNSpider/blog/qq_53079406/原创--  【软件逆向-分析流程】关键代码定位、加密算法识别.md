# 原创
：  【软件逆向-分析流程】关键代码定位、加密算法识别

# 【软件逆向-分析流程】关键代码定位、加密算法识别

 **目录**

[一、简介：](#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A)

[二、关键代码定位](#%E4%BA%8C%E3%80%81%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%BD%8D)

[2.1、API断点法](#2.1%E3%80%81API%E6%96%AD%E7%82%B9%E6%B3%95)

[2.2、字符串检索法](#2.2%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A3%80%E7%B4%A2%E6%B3%95)

[（1）在IDA中查找字符串](#%EF%BC%881%EF%BC%89%E5%9C%A8IDA%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2)

[（2）在OD中查找字符串](#%EF%BC%882%EF%BC%89%E5%9C%A8OD%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2)

[2.3、辅助工具定位法](#2.3%E3%80%81%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7%E5%AE%9A%E4%BD%8D%E6%B3%95)

[三、常见加密算法识别](#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB)

[3.1、简介：](#3.1%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A)

[3.2、base64](#3.2%E3%80%81base64)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[识别：](#%E8%AF%86%E5%88%AB%EF%BC%9A)

[3.3、TEA](#3.3%E3%80%81TEA)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[TEA的源码：](#TEA%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%9A)

[识别：](#%E8%AF%86%E5%88%AB%EF%BC%9A)

[3.4、AES](#3.4%E3%80%81AES)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[AES加密4种操作：](#AES%E5%8A%A0%E5%AF%864%E7%A7%8D%E6%93%8D%E4%BD%9C%EF%BC%9A)

[S盒和逆S盒：](#S%E7%9B%92%E5%92%8C%E9%80%86S%E7%9B%92%EF%BC%9A)

[3.5、RC4](#3.5%E3%80%81RC4)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[函数代码：](#%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%EF%BC%9A)

[3.6、MD5](#3.6%E3%80%81MD5)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[MD5加密函数：](#MD5%E5%8A%A0%E5%AF%86%E5%87%BD%E6%95%B0%EF%BC%9A)

[MD5Init](#MD5Init)

---


> 
<h2>一、简介：</h2>
在一个可执行程序（尤其是图形化的程序）中，汇编代码量比较庞大
因此需要定位出关键代码，并对关键代码采用的算法进行分析，理清程序功能。
最后针对程序功能，写出对应脚本，解出flag。


---


---


## 二、关键代码定位

> 
<h3>2.1、API断点法</h3>
在获取文本输入时，对于窗口类程序获取文本的方式主要是通过GetWindowText和GetDlgItemText两个API来获取。
在输出结果时，程序通常会弹出对话框，调用的API通常为MessageBox。
在这些API函数中下断点，在调试器中断下来之后，通过栈回溯即可定位到关键代码。


> 
<h3>2.2、字符串检索法</h3>
<h4>（1）在IDA中查找字符串</h4>
打开Strings子窗口，通过Ctrl+F快捷键输入你想要查找的字符串
<hr/>
<h4>（2）在OD中查找字符串</h4>
通过Alt+E快捷键，可以查看可执行模块，找到主模块
点击右键，选择中文搜索引擎选项，根据需要选择搜索ASCII或者搜索UNICODE


#### （2）在OD中查找字符串

> 
<h3>2.3、辅助工具定位法</h3>
针对特定语言或者编译器生成的程序，有一些辅助工具可帮助用户快速定位按键处理程序的地址，如针对MFC程序的xspy，针对Delphi程序的Dede，等等。


---


---


## 三、常见加密算法识别

> 
<h3>3.1、简介：</h3>
在对数据进行变换的过程中，通常会使用一些常用的加密算法，因此如果能够快速识别出对应的加密算法，就能更快地分析出整个完整的算法。CTF逆向中通常出现的加密算法包括base64、TEA、AES、RC4、MD5等。


> 
<h3>3.2、base64</h3>
<h4>简介：</h4>
将输入中的每3字节（共24比特）按每6比特分成一组，变成4个小于64的索引值，然后通过一个索引表得到4个可见字符
<hr/>
<h4>识别：</h4>
索引表为一个64字节的字符串
eg：发现“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”（强调是64字节），那么基本上就可以确定使用了base64
此外，还有一些变种的base64，主要是改变了这个索引表


#### 识别：

> 
<h3>3.3、TEA</h3>
<h4>简介：</h4>
常见的分组加密算法，密钥为128比特位，明文为64比特位，主要做了32轮变换，每轮变换中都涉及移位和变换
<hr/>
<h4>TEA的源码：</h4>
void encrypt(uint32_t*v,uint32_t*k) {<br/>         uint32_t v0 = v[0], v1 = v[1], sum = 0, i;<br/>         uint32_t delta = 0x9e3779b9;<br/>         uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];<br/>         for(i=0;i&lt;32;i++) {<br/>                 sum += delta;<br/>                 v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);<br/>                 v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);<br/>         }<br/>         v[0] = v0;<br/>         v[1] = v1;<br/> }<br/> void decrypt(uint32_t*v,uint32_t*k) {<br/>         uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i;
        uint32_t delta = 0x9e3779b9;<br/>         uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3];<br/>         for(i = 0; i &lt; 32; i++) {<br/>                 v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3);<br/>                 v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1);<br/>                 sum -= delta;<br/>         }<br/>         v[0] = v0;<br/>         v[1] = v1;<br/> }
<hr/>
<h4>识别：</h4>
在TEA算法中有一个固定的常数0x9e3779b9或者0x61c88647


#### TEA的源码：

---


> 
<h3>3.4、AES</h3>
<h4>简介：</h4>
常见的分组加密算法
AES的加解密流程：

<hr/>
<h4>AES加密4种操作：</h4>
字节替代（SubBytes）、行移位（ShiftRows）、列混淆（MixColumns）和轮密钥加（AddRoundKey）
其中，字节替代过程是通过S盒完成一个字节到另外一个字节的映射。
<hr/>
<h4>S盒和逆S盒：</h4>
static const uint32 FSb[256] =<br/> {<br/> 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,<br/> 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,<br/> 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,<br/> 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,<br/> 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,<br/> 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,<br/> 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,<br/> 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,<br/> 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,<br/> 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,<br/> 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,<br/> 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,<br/> 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,<br/> 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,<br/> 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,<br/> 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,<br/> 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,<br/> 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,<br/> 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,<br/> 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,<br/> 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,<br/> 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,<br/> 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,<br/> 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,<br/> 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,<br/> 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,<br/> 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,<br/> 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,<br/> 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,<br/> 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,<br/> 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,<br/> 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16<br/> };<br/> static const uint32 RSb[256] =<br/> {<br/> 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,<br/> 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,<br/> 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,<br/> 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,<br/> 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,<br/> 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,<br/> 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,<br/> 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,<br/> 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,<br/> 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,<br/> 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,<br/> 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,<br/> 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,<br/> 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,<br/> 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,<br/> 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,<br/> 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,<br/> 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,<br/> 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,<br/> 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,<br/> 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,<br/> 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,<br/> 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,<br/> 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,<br/> 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,<br/> 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,<br/> 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,<br/> 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,<br/> 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,<br/> 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,<br/> 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D<br/> };

如果发现程序中有S盒或者动态生成了S盒，则可以确定采用了AES加密。在2014 ISCC的Reverse7程序脱壳后，sub_4013B0函数就是一个AES加密


 进入字节替换子函数sub_401140之后，很明显可以发现这里用到了一个索引表byte_B6E000
AES加密算法中的字节替换函数：

查看该索引表，发现其正是我们所知道的S盒


#### AES加密4种操作：

---


> 
<h3>3.5、RC4</h3>
<h4>简介：</h4>
属于流加密算法，包括初始化函数和加解密函数
<h4>函数代码：</h4>
/*初始化函数*/<br/> void rc4_init(unsigned char*s,unsigned char*key, unsigned long Len)
{<br/>         int i=0,j=0;<br/>         //char k[256]={0};<br/>         unsigned char k[256]={0};<br/>         unsigned char tmp=0;<br/>         for(i=0;i&lt;256;i++) {<br/>                 s[i]=i;<br/>                 k[i]=key[i%Len];<br/>         }<br/>         for(i=0;i&lt;256;i++) {<br/>                 j=(j+s[i]+k[i])%256;<br/>                 tmp=s[i];<br/>                 s[i]=s[j];//交换s[i]和s[j]<br/>                 s[j]=tmp;<br/>         }<br/> }
/*加解密*/<br/> void rc4_crypt(unsigned char*s,unsigned char*Data,unsigned long Len)<br/> {<br/>         int i=0,j=0,t=0;<br/>         unsigned long k=0;<br/>         unsigned char tmp;<br/>         for(k=0;k&lt;Len;k++)<br/>         {<br/>                 i=(i+1)%256;<br/>                 j=(j+s[i])%256;<br/>                 tmp=s[i];<br/>                 s[i]=s[j];//交换s[i]和s[j]<br/>                 s[j]=tmp;<br/>                 t=(s[i]+s[j])%256;<br/>                 Data[k]^=s[t];<br/>         }<br/> }
初始化代码对字符数组s进行了初始化赋值，且赋值分别递增，之后又对s进行了256次交换操作。
通过识别初始化代码，可以判断为RC4算法。


#### 函数代码：

> 
<h3>3.6、MD5</h3>
<h4>简介：</h4>
MD5消息摘要算法，是一种被广泛使用的密码散列函数，可以产生一个128位（16字节）的散列值，用于确保信息传输的完整性和一致性
<hr/>
<h4>MD5加密函数：</h4>
MD5_CTX md5c;<br/> MD5Init(&amp;md5c);<br/> MD5UpdaterString(&amp;md5c, plain);<br/> MD5Final(digest,&amp;md5c);
<hr/>
<h4>MD5Init</h4>
会初始化四个称作MD5链接变量的整数参数。因此如果看到这4个常数0x67452301、0xefcdab89、0x98badcfe、0x10325476，就可以怀疑该函数是否为MD5算法了
MD5Init函数代码：
void MD5Init (MD5_CTX *context)<br/> /* context */<br/> {<br/>         context-&gt;count[0] = context-&gt;count[1] = 0;<br/>         /* Load magic initialization constants. */<br/>         context-&gt;state[0] = 0x67452301;<br/>         context-&gt;state[1] = 0xefcdab89;<br/>         context-&gt;state[2] = 0x98badcfe;<br/>         context-&gt;state[3] = 0x10325476;<br/> }


#### MD5加密函数：

---

