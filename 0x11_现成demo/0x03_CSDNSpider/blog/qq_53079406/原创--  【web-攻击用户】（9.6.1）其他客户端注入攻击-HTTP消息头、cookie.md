# 原创
：  【web-攻击用户】（9.6.1）其他客户端注入攻击：HTTP消息头、cookie

# 【web-攻击用户】（9.6.1）其他客户端注入攻击：HTTP消息头、cookie

**目录**

[其他客户端注入攻击](#%E5%85%B6%E4%BB%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB)

[1.1、HTTP消息头注入](#1.1%E3%80%81HTTP%E6%B6%88%E6%81%AF%E5%A4%B4%E6%B3%A8%E5%85%A5)

[1.2、利用消息头注入漏洞](#1.2%E3%80%81%E5%88%A9%E7%94%A8%E6%B6%88%E6%81%AF%E5%A4%B4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E)

[注入cookie](#%E6%B3%A8%E5%85%A5cookie)

[传送其他攻击](#%E4%BC%A0%E9%80%81%E5%85%B6%E4%BB%96%E6%94%BB%E5%87%BB)

[HTTP响应分割](#HTTP%E5%93%8D%E5%BA%94%E5%88%86%E5%89%B2)

[防止消息头注入漏洞](#%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E5%A4%B4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E)

[1.3、cookie注入：](#1.3%E3%80%81cookie%E6%B3%A8%E5%85%A5%EF%BC%9A)

---


## 其他客户端注入攻击

> 
<h3>1.1、HTTP消息头注入</h3>
1、如果用户控制的数据以不安全的方式插入到应用程序返回的HTTP消息头中，这时就会出现HTTP消息头注入漏洞。如果攻击者能够在他控制的消息头中注入换行符，他就能在响应中插入其他HTTP消息头、并在响应主体中写入任意内容。
2、这种漏洞最常见于Location与Set-Cookie消息头中，但也会出现在其他HTTP消息头中。应用程序提取用户提交的输入，并将它插入到响应码为3xx的Location消息头中。同样， 一些应用程序提取用户提交的输入，并将其插入cookie值中

3、在上述任何一种情况下，攻击者都可以使用回车符(0x0d)或换行符(0x0a)构造一个专门设计的请求在他们控制的消息头中注入一个换行符， 从而在下面的行中注入其他数据
<hr/>
[【注入后端HTTP请求】服务器端HTTP重定向、HTTP参数注入<img alt="" src="https://csdnimg.cn/release/blog_editor_html/release2.1.9/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M7J4"/>https://blog.csdn.net/qq_53079406/article/details/126444127?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166173552316781790777137%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166173552316781790777137&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-126444127-null-null.nonecase&amp;utm_term=http&amp;spm=1018.2226.3001.4450](https://blog.csdn.net/qq_53079406/article/details/126444127?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166173552316781790777137%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166173552316781790777137&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-126444127-null-null.nonecase&amp;utm_term=http&amp;spm=1018.2226.3001.4450)


> 
<h3>1.2、利用消息头注入漏洞</h3>
查找消息头注入漏洞的方法与查找XSS漏洞的方法类似，同样需要寻找用户控制的输入重复出现在应用程序返回的HTTP消息头中的情况。因此在探查应用程序是否存在XSS漏洞的过程中， 还应当确定应用程序可能易于受到消息头注入的全部位置
1、在用户控制的输入被复制到HTTP消息头中的每个位置都可能存在漏洞，确认应用程序是否接受URL编码的回车符(%0d)与换行符（%0a)，以及它们是否按原样在响应中返回
2、是在服务器的响应中而不是换行符的URL编码形式中寻找换行符本身，如通过拦截代理服务器查看响应，攻击成功的话，应该会在HTTP消息头中看到另外一个新行
3、如果服务器的响应中仅返回两个换行符中的一个，根据实际情况，仍然能够设计出有效的攻击方法
4、如果发现换行符被应用程序阻止或净化．那么应该尝试攻击方法：
foo%00%0d%0abar
foo%250d%250abar
foo%%0d0d%%0a0abar

如果能够在响应中注入任意消息头和消息主体内容，那么这种行为可通过各种方式攻击应用程序的其他用户
<hr/>
<h4>注入cookie</h4>
攻击者可以建立一个URL，在请求它的任何用户的浏览器中设定任意cookie
如果进行适当配置， 这些cookic可以访问不同的浏览器会话，通过前面利用反射型XSS漏洞时使用的相同传送机制（电子邮件、第三方Web站点等），就可以诱使目标用户访问恶意URL
<hr/>
<h4>传送其他攻击</h4>
因为HTTP消息头注入允许攻击者控制整个响应主体，所以几乎任何针对其他用户的攻击都可以使用它作为传送机制， 包括虚拟Web站点置换、脚本注入、任意重定向，针对ActweX控件的攻击等。
<hr/>
<h4>HTTP响应分割</h4>
这是一种试图通过恶意内容危害代理服务器缓存，从而攻破通过代理服务器访问应用程序的其他用户的攻击技巧。如果企业网络中的所有用户通过缓存代理服务器访问某个应用程序， 那么通过在代理服务器的缓存中注入恶意内容（显示给任何请求受影响页面的用户），攻击者就可以向这些用户实施攻击

攻击者可以按以下步骤， 利用消息头注入漏洞来实施响应分割攻击
（1）攻击者在代理服务器缓存中选择一个他希望危害的应用程序页面。如用一个木马登录表单（用于向攻击者的服务器提交用户证书）代替/admin/处的页面。
（2）攻击者确定某个消息头注入漏洞，构造一个请求，在服务器响应中注入一个完整的HTTP主体以及另一组响应消息头和另一个响应主体，第二个响应主体中包含他的木马登录表单的HTML代码。这样，服务器的响应看起来就像是两个连接在一起的单独HTTP响应，这种技巧叫做HTTP响应分割，因为攻击者已经把服务器的响应"分割"成两个单独的响应。
(3)攻击者与代理服务器建立TCP连接，传送这个专门设计的请求，后面紧跟着访问被危害的页面的请求。在HTTP协议中，以这种方式连接请求是合法的。
(4)代理服务器与应用程序建立TCP连接，送出这两个以相同方式连接的请求。
(5)应用程序用攻击者注入的HTTP内容响应第一个请求，它看起来就像是两个单独的HTTP响应
(6) 代理服务器收到这两个看似单独的响应，并认为其中第二个响应与攻击者的第二个请求相对应，该请求指向URL:http://mdsec.net/admin/。代理服务器把第二个响应作为这个URL的内容保存在缓存中。（如果代理服务器已经在缓存中保存有该页面的副本，那么攻击者就可以在他的第二个请求中插入一个适当的If-Modified-Since消息头，并在注入的响应中插入一个Last-Modified消息头，使得代理服务器重新请求这个URL，用新的内容更新它的缓存。）
(7)应用程序发布它对攻击者的第二个请求的响应，其中包含URL:http://mdsec.net/admin/的真实内容。代理服务器并不认为它是对它发布的请求的响应，因而抛弃这个响应。
(8)一名用户通过代理服务器访问http://mdsec.net/admin/，并收到这个URL保存在代理服务器缓存中的内容。这个内容实际上是攻击者的木马登录表单， 因此用户的证书被攻破
<hr/>
<h4>防止消息头注入漏洞</h4>
要防止HTTP消息头注入漏洞，最有效方法是杜绝将用户控制的输入插入到应用程序返回的HTTP消息头中。通常可以用一些较为安全的方法代替这种行为。
如果不可避免地要在HTTP消息头中插入用户控制的数据，那么应用程序应采取以下双重深层防御方法防止漏洞产生：<br/> 1、输入确认：应用程序应根据情形，对插入的数据进行尽可能严格的确认。如果根据用户输入设定一个cookie值，那么应将这个值限制为仅包含字母字符，及大长度为6字节。
2、输出确认：应对插入到消息头中的所有数据进行过滤，检测可能的恶意字符。实际上，任何ASCII码小于0x20的字符都应被视为可疑的恶意字符，应用程序应拒绝包含这些字符的请求。
只有应用程序在其SSL终止符后未使用缓存反向代理服务器，它才能通过对所有应用程序内容使用HTTPS，防止攻击者利用任何残留的消息头注入漏洞危害代理服务器缓存。


---


#### 传送其他攻击

---


#### 防止消息头注入漏洞

> 
<h3>1.3、cookie注入：</h3>
[【SQL注入】cookie注入：原理、步骤、示例<img alt="" src="https://csdnimg.cn/release/blog_editor_html/release2.1.9/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M7J4"/>https://blog.csdn.net/qq_53079406/article/details/125685994?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166173535816780357239574%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166173535816780357239574&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-125685994-null-null.nonecase&amp;utm_term=cookie&amp;spm=1018.2226.3001.4450](https://blog.csdn.net/qq_53079406/article/details/125685994?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166173535816780357239574%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=166173535816780357239574&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-125685994-null-null.nonecase&amp;utm_term=cookie&amp;spm=1018.2226.3001.4450)

