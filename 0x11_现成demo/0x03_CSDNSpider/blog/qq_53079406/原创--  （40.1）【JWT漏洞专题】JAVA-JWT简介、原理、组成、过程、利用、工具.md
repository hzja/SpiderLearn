# 原创
：  （40.1）【JWT漏洞专题】JAVA-JWT简介、原理、组成、过程、利用、工具

# （40.1）【JWT漏洞专题】JAVA-JWT简介、原理、组成、过程、利用、工具

**目录**

[一、前言：](#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80%EF%BC%9A)

[二、JWT（JSON Web令牌）简介：](#%E4%BA%8C%E3%80%81JWT%EF%BC%88JSON%20Web%E4%BB%A4%E7%89%8C%EF%BC%89%E7%AE%80%E4%BB%8B%EF%BC%9A)

[三、优点：](#%E4%B8%89%E3%80%81%E4%BC%98%E7%82%B9%EF%BC%9A)

[四、原理：](#%E5%9B%9B%E3%80%81%E5%8E%9F%E7%90%86%EF%BC%9A)

[五、功能：](#%E4%BA%94%E3%80%81%E5%8A%9F%E8%83%BD%EF%BC%9A)

[六、组成：](#%E5%85%AD%E3%80%81%E7%BB%84%E6%88%90%EF%BC%9A)

[6.1、头部(Header)](#6.1%E3%80%81%E5%A4%B4%E9%83%A8%28Header%29)

[6.1.1、介绍：](#6.1.1%E3%80%81%E4%BB%8B%E7%BB%8D%EF%BC%9A)

[6.1.2、示例：](#6.1.2%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[6.1.3、注：](#6.1.3%E3%80%81%E6%B3%A8%EF%BC%9A)

[6.2、Payload](#6.2%E3%80%81Payload)

[6.2.1、介绍：](#6.2.1%E3%80%81%E4%BB%8B%E7%BB%8D%EF%BC%9A)

[6.2.2、载荷示例：](#6.2.2%E3%80%81%E8%BD%BD%E8%8D%B7%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[6.2.3、声明（Claims）：](#6.2.3%E3%80%81%E5%A3%B0%E6%98%8E%EF%BC%88Claims%EF%BC%89%EF%BC%9A)

[6.2.4、参数：](#6.2.4%E3%80%81%E5%8F%82%E6%95%B0%EF%BC%9A)

[6.3、签名（Signature）](#6.3%E3%80%81%E7%AD%BE%E5%90%8D%EF%BC%88Signature%EF%BC%89)

[6.3.1、简介：](#6.3.1%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A)

[6.3.2、示例：](#6.3.2%E3%80%81%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[七、认证过程：](#%E4%B8%83%E3%80%81%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%EF%BC%9A)

[八、利用方法：](#%E5%85%AB%E3%80%81%E6%94%BB%E5%87%BB%EF%BC%9A)

[8.1、第一步：识别JWT](#8.1%E3%80%81%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E8%AF%86%E5%88%ABJWT)

[8.2、第二步：测试已知漏洞](#8.2%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%B5%8B%E8%AF%95%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E)

[8.3、第三步：利用方法](#8.3%E3%80%81%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95)

[8.4、第四步：GET密钥](#8.4%E3%80%81%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E7%A0%B4%E8%A7%A3%E5%AF%86%E9%92%A5)

[九、工具:](#%E4%B9%9D%E3%80%81%E5%B7%A5%E5%85%B7%3A)

[9.1、The JSON Web Token Toolkit v2](#9.1%E3%80%81The%20JSON%20Web%20Token%20Toolkit%20v2)

[9.2、JWT cracker](#9.2%E3%80%81JWT%20cracker)

---


  

---


## 一、前言：

> 
谈起web安全，不得不想起以下内容（JAVA）
（1）基操
SQL注入、路径遍历、XSS跨站、反序列化、XML&amp;XXE、CSRF&amp;SSRF
（2）访问控制
对象引用、缺少功能
（3）身份验证
身份验证绕过、JWT令牌、重设密码、安全密码
（4）客户端安全
前端限制、客户端过滤、HTML修改
（5）组件安全
中间件


---


## 二、JWT（JSON Web令牌）简介：

> 
JSON web Token 一种跨域验证身份的方案。JWT不加密传输的数据，通过数字签名来验证数据未被篡改（无状态的认证机制）,通常用于授权和信息交换。
— — — — — —
重要性：JWT不仅是让你获得无限访问权限的关键，而且还被视为隐藏了通往以下特权的途径：特权升级，信息泄露，SQLi，XSS，SSRF，RCE，LFI等
— — — — — —
JWT的测试过程取决于不同JWT配置和实现，对目标服务的Web请求中使用的Token进行读取，篡改和签名，可能遇到已知的利用方式以及潜在的安全漏洞和配置错误


---


## 三、优点：

> 
大小：由于JSON的详细性小于XML，因此编码其大小也小时也小，使JWT比SAML更紧凑。这使JWT成为在HTML和HTTP环境中通过的好选择。
— — — —
安全：SWT只能通过使用HMAC算法的共享秘密对称签名。但是，JWT和SAML令牌可以使用X.509证书的形式使用公共/私钥对进行签名。与签名JSON的简单性相比，使用XML数字签名签名XML没有引入晦涩的安全孔，这是非常困难的。
— — — —
断言：JSON解析器在大多数编程语言中都是常见的，因为它们直接映射到对象。相反，XML没有自然的文档对象映射。这使与JWT合作比SAML断言更容易。
— — — —
份额：JWT在Internet规模上使用。这突出了JSON Web令牌在多个平台（尤其是移动设备）上的客户端处理的便捷性。


---


## 四、原理：

> 
通过数字签名来验证数据未被篡改,可以被验证和信任
JWT 三部分：头部（Header).声明（Claims).签名（Signature）
三个部分以英文句号.隔开,JWT 的内容以 Base64URL 进行了编码
— — — —
（1）可以使用secret（HMAC算法）或使用“RSA或ECDSA的公用/私有key pair密钥对”对JWT进行签名。
（2）signed tokens（已签名的令牌）可以验证其中包含的claims（声明）的完整性
（3）encrypted tokens（加密的令牌）则将其他方的claims（声明）隐藏
（4）当使用“公钥/私钥对”对令牌进行签名时，只有持有私钥的一方才是对其进行签名的一方


---


## 五、功能：

> 
1、授权
这是使用JWT的最常见方案。一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。单点登录是今广泛使用JWT的一项功能，因为它的开销很小并且可以在不同的域中轻松使用。
— — — —
2、信息交换
JSON Web Token是在各方之间安全地传输信息的好方法。因为可以对JWT进行签名（例如，使用公钥/私钥对），所以可以确保发件人是本人。此外，由于签名是使用标头和有效负载计算的，因此还可以验证内容是否遭到篡改。


---


## 六、组成：

> 
JwT分为三部分，头部(Header)，声明(claims)，签名(signature)
**令牌组成：header.payload.signature**




> 
<h3>6.1、头部(Header)</h3>
<h4>6.1.1、介绍：</h4>
描述的是最基本的信息，通常由两部分组成：令牌的类型（即JWT）和所使用的签名算法。
并使用Base64编码组成JWT结构的第一部分
<h4>6.1.2、示例：</h4>
{“alg”:“HS256”,   // 加密算法
“typ” : “JWT”  // 类型
}
<h4>6.1.3、注：</h4>
//alg<br/> 指JWT签名使用的算法参数，HS256表示HMAC SHA256。常见值用s256(默认)，Hs512等，也可以为None。
//typ<br/> 指token的类型为JWT


#### 6.1.2、示例：

> 
<h3>6.2、Payload</h3>
<h4>6.2.1、介绍：</h4>
令牌的第二部分是有效负载（包含声明，用户信息交换）， token 的一些基本信息，以帮助接受它的服务器来理解这个 token
声明是有关实体（通常是用户）和其他数据的声明
并使用Base64编码组成JWT结构的第二部分
— — — —
<h4>6.2.2、载荷示例：</h4>
{<br/> "sub": "1234567890",<br/> "name": "John Doe",<br/> "admin": true<br/> }<br/> — — — —

<h4>6.2.3、声明（Claims）：</h4>
{undefined<br/> “exp”: 1416471934,//到期时间<br/> “user_name”: “user”,<br/> “scope”: [<br/> “read”,<br/> “write”<br/> ],<br/> “authorities”: [<br/> “ROLE_ADMIN”,<br/> “ROLE_USER”<br/> ],<br/> “jti”: “9bc92a44-0b1a-4c5e-be70-da52075b9a84”,//JwT ID用于标识该JwT<br/> “client_id”: “my-client-with-secret”<br/> }
— — — —
<h4>6.2.4、参数：</h4>
JWT固定参数(但并不是必须):
iss:发行人、exp:到期时间、sub:主题
aud:用户、nbf:在此之前不可用
iat:发布时间、jti: JwT ID用于标识该JwT


#### 6.2.2、载荷示例：

#### 6.2.4、参数：

> 
<h4>6.3、签名（Signature）</h4>
<h4>6.3.1、简介：</h4>
Header.Payload.Signature（签名在最后），验证消息在整个过程中没被更改，并且对于使用私钥进行签名的令牌，它还可以验证JWT的发送者是它所说的真实身份。
创建签名，必须获取编码的头部，编码的有效载荷，密钥，头部中指定的算法，并对其进行签名
签名：服务器有一个不会发送给客户端的密码（secret），用头部中指定的算法对头部和声明的内容用此密码进行加密，生成的字符串就是 JWT 的签名。


<h4>6.3.2、示例：</h4>
HS256 生成 JWT <br/> HMACSHA256(<br/> base64UrlEncode(header) + "." +<br/> base64UrlEncode(payload),<br/> secret)


#### 6.3.1、简介：

---


## 七、认证过程：

> 
 （1）用户端登录，通过前端web表单，把用户名和密码在请求中发往服务器接口，通过SSL加密的传输（https协议），从而避免敏感信息被嗅探（一般是HTTP POST）
— —
（2）(确认登录信息正确后)服务器生成json头部和声明，将登录信息写入JsoN的声明中(通常不应写入密码，因为JwT是不加密的)，并用secret用指定算法进行加密,生成该用户的JwT。此时，服务器并没有保存登录状态信息。
— —
（3）服务器将JwT (通过响应)作为登录成功的结果返回给客户端，前端可以将返回的结果保存在localStorage或sessionStorage中，退出登录时前端删除保存的JWT
— —
（4）用户下次会话时（每次请求），客户端会自动将JwT写在HTTP Header的Authorization字段中
— —
（5）服务器对JwT有效性验证，若验证成功，则确认此用户的登录状态
 — —
（6）使用JWT中包含的用户信息进行其他逻辑操作，并返回响应






---


## 八、利用方法：

> 
<h3>8.1、第一步：识别JWT</h3>
使用BP代理，历史记录会保存
使用正则匹配JWT：
//网址的JWT版本<br/> eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9._-]*
//所有JWT版本（误报的可能性更高）<br/> eyJ[A-Za-z0-9_\/+-]*\.[A-Za-z0-9._\/+-]*


> 
<h3>8.2、第二步：测试已知漏洞</h3>
用jwt_tool测试已知漏洞
测试漏洞-RSA密钥混淆（CVE-2016-5431）
测试漏洞-JWKS注入（CVE-2018-0114）
……


> 
<h3>8.3、第三步：利用方法</h3>
（1）寻找需要JWT认证页面（人资料页……），重发JWT，分析响应变化
— —
（2）删除令牌观察结果，并检查标头、Cookie或POST数据等其他授权手段
— —
（3）删除签名的最后几个字符，检查响应成功或失败。分析详细错误信息，看是否能获取敏感内容，若删除前后返回页面相同，则不检查签名；反之不同，检测。
— —
（4）重新发送同一令牌多次，穿插不发送令牌，或者一次发送无效签名（从令牌末尾删除一个或两个字符）。
若正常，相同的JWT还未注销，或在注销后或持续很长时间后仍然有效（不朽）；
反之，令牌失效，可以以编程方式调用“刷新令牌” API
— —
（5）寻找令牌在哪创建（正常情况是服务器），若是客户端，则可以访问并获取该密钥 
— —
（6）使用工具The JSON Web Token Toolkit v2更改能直接在页面上呈现的任何有效载荷，同时保持签名不变。
先修改头部，再修改载荷，最后选择保持原本签名。分析页面响应，若被更改，则说明在验证以前就处理了这些操作，尝试去修改更重要的内容


> 
<h3>8.4、第四步：GET密钥</h3>
HMAC签名密钥（例如HS256 / HS384 / HS512）使用对称加密（加解密同一秘钥）
使用工具破解
The JSON Web Token Toolkit v2
JWT cracker
（最后带GitHub地址）


---


## 九、工具:

> 
<h3>9.1、The JSON Web Token Toolkit v2</h3>
用于测试，调整和po解JSON网络令牌的工具包
https://github.com/ticarpi/jwt_tool


> 
<h3>9.2、JWT cracker</h3>
用C编写的多线程JWT Brute-Force Cracker。如果您很幸运或具有巨大的计算能力，则该程序应该找到JWT令牌的秘密钥匙，使您可以伪造有效的令牌。
https://github.com/brendan-rius/c-jwt-cracker

