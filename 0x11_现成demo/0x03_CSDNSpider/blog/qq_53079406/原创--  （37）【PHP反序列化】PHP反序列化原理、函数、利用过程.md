# 原创
：  （37）【PHP反序列化】PHP反序列化原理、函数、利用过程

# （37）【PHP反序列化】PHP反序列化原理、函数、利用过程

**目录**

[一、简介：](#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A)

[二、原理：](#%E4%BA%8C%E3%80%81%E5%8E%9F%E7%90%86%EF%BC%9A)

[2.1、函数：](#2.1%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%9A)

[2.1.1、serialize()序列化](#2.1.1%E3%80%81serialize%28%29%E5%BA%8F%E5%88%97%E5%8C%96)

[2.1.2、unserialize()反序列化](#2.1.2%E3%80%81unserialize%28%29%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)

[三、常见的序列化格式：](#%E4%B8%89%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%A0%BC%E5%BC%8F%EF%BC%9A)

[四、产生的原因：](#%E5%9B%9B%E3%80%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A)

[4.1、无类：](#4.1%E3%80%81%E6%97%A0%E7%B1%BB%EF%BC%9A)

[4.2、有类：](#4.2%E3%80%81%E6%9C%89%E7%B1%BB%EF%BC%9A)

[五、魔术方法（触发）：](#%E4%BA%94%E3%80%81%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%EF%BC%88%E8%A7%A6%E5%8F%91%EF%BC%89%EF%BC%9A)

[六、利用：](#%E5%85%AD%E3%80%81%E5%88%A9%E7%94%A8%EF%BC%9A)

[6.1、分析](#6.1%E3%80%81%E5%88%86%E6%9E%90)

[6.2、构造序列化](#6.2%E3%80%81%E6%9E%84%E9%80%A0%E5%BA%8F%E5%88%97%E5%8C%96)

[6.3、输入执行](#6.3%E3%80%81%E8%BE%93%E5%85%A5%E6%89%A7%E8%A1%8C)

---


（智者千虑，必有一失） 

---


## 一、简介：

> 
序列化就是将数据转化成一种可逆的字符串，字符串还原原来结构的过程叫做反序列化
序列化后，方便保存和传输（保留成员变量，不保留函数方法）

数据（对象）--------序列化----------&gt;字符串-----------反序列化--------&gt;数据（对象）


## 二、原理：

### 2.1、函数：

> 
<h4>2.1.1、serialize()序列化</h4>
将一个对象转换成可以传输的一个字符串
序列化对象后，可以方便的将它传递到其他需要它的地方，且其类型和结构不会改变
eg：
class S{
public $test="pikachu";
}
$s=new S(); //创建一个对象
serialize($s); //把这个对象进行序列化


> 
<h4>2.1.2、unserialize()反序列化</h4>
将序列化后的字符串还原成一个对象，或数组（即进行反序列化），并返回原始的对象结构
并在后面的代码中继续使用，加密后的字符串如下所示


对字符串代码进行分析：
$u=unserialize("O:1:"S":1:{s:4:"test";s:7:"pikachu";}");
echo $u-&gt;test; //得到的结果为pikachu

O:1:"S":1:{s:4:"test";s:7:"pikachu";} //这是序列化结果
O:代表object         1:代表对象名字长度为一个字符         S:对象名称         1:代表对象里面有一个变量          s:数据类型        4:变量名长度         test:变量名称         s:数据类型         7:变量值的长度         pikachu:变量值


---


## 三、常见的序列化格式：

> 
二进制格式
字节数组
json字符串
xml字符串
……


> 
布尔型（bool）：b
整数型（int）：i
字符串型（str）：s
数组型（array）：a
对象型（object）：O
NULL型：N


---


 

## 四、产生的原因：

> 
对用户的输入检测不严

<h4>4.1、无类：</h4>
当未检测出攻击者输入的序列化字符串中包含的恶意执行语句
攻击者从而达到控制反序列化过程，进而进行恶意代码的执行（好比SQL注入，目录遍历等操作）

<h4>4.2、有类：</h4>
当进行反序列化的时候就有可能会触发对象中的一些魔术方法


#### 4.2、有类：

---


## 五、魔术方法（触发）：

> 
(前提：有可利用的类）
__construct()        //创建对象时触发
__destruct()        //对象销毁时触发
__call()        //在对象中调用不可访问的方法时触发
__callStatic()        //在静态中调用不可访问的方法时触发
__get()        //用于从不可访问的属性读取数据
__set()        //用于将数据写入不可访问的属性
__isset()        //在不可访问的属性上调用isset()或empty()触发
__unset()        //在不可访问的属性上使用unset()时触发
__invoke()        //当脚本尝试将对象调用为函数时触发
__wakeup()        //执行unserialize()时，先会调用这个函数
__sleep()        //执行serialize()时，先会调用这个函数


---


## 六、利用：

> 
<h3>6.1、分析</h3>
因为这是反序列化API
所以要先把包含执行语句的php序列化



> 
<h3>6.2、构造序列化</h3>
编写包含恶意语句的php
下面是一个弹窗
<blockquote>
-------------------------------------------
&lt;?php<br/>  <br/> class S{<br/>         var $test = "&lt;script&gt;alert('xss')&lt;/script&gt;";<br/> }
$a = new S();<br/> echo serialize($a);<br/> ?&gt;
------------------------------------------


 

构造出来是：

O:1:"S":1:{s:4:"test";s:29:"&lt;script&gt;alert('xss')&lt;/script&gt;";}

并将其进行序列化（网上的在线工具都可）

> 
<h3>6.3、输入执行</h3>
将序列化后的复制到输入框提交
会产生弹窗


