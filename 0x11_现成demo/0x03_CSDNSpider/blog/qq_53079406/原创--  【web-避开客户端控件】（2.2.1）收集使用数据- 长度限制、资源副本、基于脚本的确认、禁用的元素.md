# 原创
：  【web-避开客户端控件】（2.2.1）收集使用数据： 长度限制、资源副本、基于脚本的确认、禁用的元素

# 【web-避开客户端控件】（2.2.1）收集使用数据： 长度限制、资源副本、基于脚本的确认、禁用的元素

**目录**

[收集使用数据： HTML表单](#%E6%94%B6%E9%9B%86%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%EF%BC%9A%20HTML%E8%A1%A8%E5%8D%95)

[1.1、简介：](#1.1%E3%80%81%E7%AE%80%E4%BB%8B%EF%BC%9A)

[1.2、长度限制](#1.2%E3%80%81%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6)

[示例：](#%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[1.3、资源副本](#1.3%E3%80%81%E8%B5%84%E6%BA%90%E5%89%AF%E6%9C%AC)

[示例：](#%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[分析：](#%E5%88%86%E6%9E%90%EF%BC%9A)

[1.4、基于脚本的确认](#1.4%E3%80%81%E5%9F%BA%E4%BA%8E%E8%84%9A%E6%9C%AC%E7%9A%84%E7%A1%AE%E8%AE%A4)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[示例：](#%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[流程：](#%E6%B5%81%E7%A8%8B%EF%BC%9A)

[1.5、禁用的元素](#1.5%E3%80%81%E7%A6%81%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0)

[简介：](#%E7%AE%80%E4%BB%8B%EF%BC%9A)

[示例：](#%E7%A4%BA%E4%BE%8B%EF%BC%9A)

[流程：](#%E6%B5%81%E7%A8%8B%EF%BC%9A)

---


## 收集使用数据： HTML表单

> 
<h3>1.1、简介：</h3>
应用程序使用客户端控件限制客户端提交的数据的另一个主要控制对象，是最初不由服务器指定， 而是由客户端自己收集的数据
HTML表单是一种最简单、及常用的机制，主要用于从用户收集输入并将其提交给服务器。用户在已命名的文本字段中输入数据，再将它们以名/值对的形式提交给服务器，是这种方法的最基本应用。表单还有其他用法，即对用户提交的数据施加限制或执行确认检查
当应用程序使用这些客户端控件作为安全机制， 防御恶意输入时，攻击者通常能够轻易避开这些控件，致使应用程序非常易于受到攻击


> 
<h3>1.2、长度限制</h3>
<h4>示例：</h4>
规定Quantity字段的最大长度为1
Quantity &lt;input type="text"  name="Quantity" maxlength="1"&gt; ＜br/＞
浏览器将阻止用户在输入字段中输人任何超过1个字符的值， 而且服务器瑞应用程序也认为它收到的quantity参数将小于10。
使用bp拦截提交表单的请求，并在其中输入任意值， 或拦截包含表单的响应，并删除maxlength属性， 就可绕过限制


> 
<h3>1.3、资源副本</h3>
<h4>示例：</h4>
拦截并修改服务器响应时，显示：
HTTP/1.1 304 Not Modified
Date：
Etag：
Expires：
Cache-Control：
<hr/>
<h4>分析：</h4>
已经在缓存中保存了所请求资源的副本，再请求时就响应这个
当浏览器请求一个已存入缓存的资源时，通常会在请求中添加另外两个消息头
If-Modified-Since：
If-None-Match：
（消息头告诉服务器浏览器上次更新缓存副本的时间）
Etag字符串（由服务器随资源副本一起提供）是一种序列号， 服务器为每个可缓存的资源分配一个Etag, 如果资源被修改，它也会随之更新
如果服务器拥有比If-Modified-Since悄息头中指定日期更新的资源， 或者如果当前版本的Etag与If-None-Match消息头中指定的Etag不匹配， 那么服务器就会在响应中提供最新的资源。
反之将返回304响应，通知浏览器资源没有被修改，并使用缓存中的副本

拦截并修改浏览器保存在缓存中的资源， 可以拦截相关请求并删除If-Modified-Since和If-None-Match消息头，让服务器在响应中提供所请求资源的完整版本。Bp中可以从每个请求中删除这些消息头，可覆盖由浏览器发送的所有缓存信息


#### 分析：

> 
<h3>1.4、基于脚本的确认</h3>
<h4>简介：</h4>
HTML表单内置的输入确认机制极其简单， 而且不够详细， 不足以对各种输入执行相关确认。<br/> 如，用户注册表单中可能包含姓名、电子邮件地址、电话号码、邮政编码等， 所有字段都要求不同的输入。开发者通常在脚本中执行定制的客户端输入确认
<hr/>
<h4>示例：</h4>
&lt;script&gt;function validateForm(theForm)<br/> {<br/>         var isInteger = /~\d+$/;<br/>         var valid = isInteger test(quantity) &amp;&amp;<br/>                quantity &gt; 0 &amp;&amp; quantity &lt;＝ 100;<br/>         if (!valid)
                alert("xxxxxx");
        return valid;
}
&lt;/script&gt;
form标签的onsubmit属性指示浏览器在用户单击“提交” 按钮时运行ValidateForm函数，井且只有在该函数返回"真"时才提交表单。这种机制帮助客户端阻止提交表单的企图，对用户的输人执行定制的确认检查， 进而决定是否接受该输入。这里只简单检查在amout字段中输入的数据是否为介于1到100之间的整数。
1、客户端控制非常容易解除，通常禁用浏览器中的JavaScript，如果忽略onsubmic风险，不需要任何定制确认就可提交表单
2、如果应用程序依靠客户端脚本执行正常操作（如用户界面），完全禁用JavaScript可能会终止应用程序。可以尝试在浏览器的输入字段中输入一个良性值， 然后用代理服务器拦截确认后提交的表单，并将其中的数据修改成想要的值。这是解除基于JavaScript的确认的最简单有效的方法
3、可以拦截包含JavaScript确认程序的服务器响应， 修改其脚本使其失效，即更改每一个ValidateForm函数使其返回"真"即可
<hr/>
<h4>流程：</h4>
1、在提交表单前使用客户端JavaScnp进行输人确认的情况
2、修改所提交的请求， 在其中插入无效数据， 或修改确认代码使其失效， 向服务器提交确认机制通常会阻止的数据
3、确定服务器是否采用了和客户端相同的控件，如果并非如此， 确定是否可利用这种情况实现任何恶意意图
4、如果在提交表单前有几个输入字段需要由客户端确认机制检验， 需要分别用无效数据测试每一个字段， 同时在所有其他字段中使用有效数据。如果同时在几个字段中提交无效数据， 可能服务器在识别出第一个无效字段时就已经停止执行表单， 从而使测试无法到达应用程序的所有可能代码路径
（只有当服务器并未采用和客户端相同的确认机制， 以及能够避开客户端确认的专门设计的输入可在应用程序中造成某种无法预料的行为时， 应用程序才存在风险。）


#### 示例：

---


> 
<h3>1.5、禁用的元素</h3>
<h4>简介：</h4>
如果HTML表单中的一个元素标记为禁用， 它会在屏幕上出现， 但以灰色显示， 并且无法像常规控件那样编辑或使用， 提交表单时，也不向服务器传送这个元素
<hr/>
<h4>示例：</h4>
price : ＜input type="text" disable="true" name="price" value="100"
这个表单中的产品价格位于禁用的文本字段中， 并出现在屏幕上
存在禁用字段可能是前面已经使用过price参数，并已经提交给服务器处理了。应当测试服务器端应用程序是否仍然会处理这个参数，可以尝试对这种情况加以利用
<hr/>
<h4>流程：</h4>
1、在应用程序的每一个表单中寻找禁用的元素。尝试将发现的每一个元素与表单的其他参数一起提交给服务器， 确定其是否有效
2、如果提交元素被标记为禁用， 其按钮即以灰色显示， 表示相关操作无效。这时尝试提交这些元素的名称，确定应用程序是否在执行所请求的操作前执行服务器端检查
3、在提交表单时， 浏览器并不包含禁用的表单元素，仅仅通过浏览应用程序的功能以及监控由浏览器发布的请求并不能确定其中是否含有禁用的元素。要确定禁用的元素， 必须监控服务器的响应或在浏览器中在看页面来源
4、使用bp中的HTML修改功能自动重新启用应用程序中的任何禁用的字段


#### 示例：

---

