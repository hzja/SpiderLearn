# 转载
：  Xstream反序列化分析（CVE-2021-39149）

# Xstream反序列化分析（CVE-2021-39149）

前几个月XStream爆出一堆漏洞，这两天翻了翻，发现这波洞应该是黑名单绕过的最后一波了。因为在最新版的XStream 1.4.18中已经默认开启白名单的安全框架，按照XStream官方补漏洞的习惯，应该不会再接受新的绕过黑名单的漏洞了。

### 挑肥拣瘦

这波漏洞一共14个，基本上都是RCE的级别，先简单梳理一下。

|CVE ID|PoC
|------
|CVE-2021-39139|RCE
|CVE-2021-39140|DoS
|CVE-2021-39141|JNDI Based RCE
|CVE-2021-39144|RCE
|CVE-2021-39145|JNDI Based RCE
|CVE-2021-39146|JNDI Based RCE
|CVE-2021-39147|JNDI Based RCE
|CVE-2021-39148|JNDI Based RCE
|CVE-2021-39149|RCE
|CVE-2021-39150|SSRF
|CVE-2021-39151|JNDI Based RCE
|CVE-2021-39152|SSRF
|CVE-2021-39153|RCE
|CVE-2021-39154|JNDI Based RCE

我是一个挑肥拣瘦的人，一向不怎么看基于JNDI这种需要出网的PoC。因为我认为出网就意味着限制，不仅是是否能够出网的限制，还有复杂网络环境导致的一系列变化多端的因素，所以这种限制就意味成功概率极大降低。所以目标范围缩小到`CVE-2021-39139`，`CVE-2021-39144`，`CVE-2021-39149`，`CVE-2021-39153`。那就看看这四个洞的详细介绍吧，哪个限制最少就分析哪个。

|CVE ID|Restrictions
|------
|CVE-2021-39139|JDK版本要在7u21及以下，很明显是用了7u21的洞转换的
|CVE-2021-39144|无限制
|CVE-2021-39149|无限制
|CVE-2021-39153|JDK版本限制在8到14且要求同时安装了JavaFX

具体看看无限制的两个洞的官方PoC都长什么样，`39144`看上去是直接可以调用到`java.lang.Runtime`，直接执行任意命令基本是没跑了，但这种情况大多数应该是盲打，或者还是利用出网的技巧。`39149`就非常给力了，一眼就看到了我们熟悉的老伙伴`TemplatesImpl`，这就意味着我们可能可以注入Java字节码实现任意类实例化，撺掇一下就可以实现回显攻击了，简直是扫描利器。所以基本目标定在了分析`CVE-2021-39149`这个漏洞。

值得一提的是那个限制了JDK版本为7u21及以下的洞也用到了`TemplatesImpl`，当然了，7u21本身确实也用到了`TemplatesImpl`，所以不值得什么大惊小怪。（不过我非要提这么一嘴，当然是要你注意这个地方，下文有呼应XD。）

### 跳坑

XStream官方是最令安全仔开心的官方，PoC都明晃晃地放在官网上，都不用费力气去diff补丁（或者偷别人的payload）。那么接下来就是基本操作了

```
&lt;proxy class='com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl' serialization='custom'&gt;
```

接着我们就运行一下，基本上来说XStream官方提供的直接RCE的payload都是弹Windows上的计算器，也就是执行calc.exe命令。但是运行后，迎来了第二个报错。

这个地方属实有点奇怪，我实际在这里卡了将近一天的时间，在很多地方下了断点跟踪分析，基本上定位到了问题可能是出在proxy标签以内，也就是TemplatesImpl类的实例化位置，但仍然就是找不出来根本问题在哪里。在卡了很久以后，我转战了CVE-2021-39139，因为这也是同样用到了TemplatesImpl类，觉得可能在这或许可以找到突破口。然后同样基本操作了一遍，居然报了一样的错误。不过确实，在对比了两个payload在TemplatesImpl位置的代码，除了字节码的Base64编码不太一样，其他都一样。

但是这边有个很不一样的点，就是`_bytecode`标签里面塞入了两段byte-array标签，且这两个payload对应的第二段byte-array标签里面内容一模一样。我拿去base64解码了一下，有一些`ysoserial`的关键字，其他得不到任何有用的信息。于是我拿着第二段的base64编码值去Google了一下。发现在一个讲解泛微之前爆出的XStream漏洞的payload中出现了一模一样的base64编码值，也同样处在了`TemplatesImpl`这个类里面。但是我手头没有泛微的demo没法验证泛微那个payload是否有效。（其实后面复盘发现，这边是个蠢操作，我完全可以摘出泛微payload中XStream那部分拿到本地测试一下就行了）所以我接着看了一些关于如何生成泛微这个payload的相关文档，得知可以通过在引入ysoserial的包生成任意已有gadget的XStream形式的payload。生成代码是我抄的potats0发在p神的小密圈的code，如下：

```
java.util.LinkedHashSet
    java.lang.reflect.Proxy
        com.sun.corba.se.spi.orbutil.proxy.CompositeInvocationHandlerImpl
            sun.tracing.NullProvider
                sun.tracing.dtrace.DTraceProbe
                    com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl
```

关键的触发其实也很简单，就是在`NullProvider`的构造器部分，它的`probes`属性是`HashMap`类型的，关键的危险代码放在value部分，那么自然就和大多数`ysoserial`中的gadget一样就用`hashcode()`这个函数进行触发了。

按部就班构造序列化数据的Java代码就很简单了，如下：

```
start:1007, ProcessBuilder (java.lang)
exec:620, Runtime (java.lang)
exec:450, Runtime (java.lang)
exec:347, Runtime (java.lang)
&lt;clinit&gt;:-1, Pwner633505606593 (ysoserial)
newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)
newInstance:62, NativeConstructorAccessorImpl (sun.reflect)
newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)
newInstance:422, Constructor (java.lang.reflect)
newInstance:442, Class (java.lang)
getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:497, Method (java.lang.reflect)
uncheckedTrigger:58, DTraceProbe (sun.tracing.dtrace)
triggerProbe:269, ProviderSkeleton (sun.tracing)
invoke:178, ProviderSkeleton (sun.tracing)
invoke:82, CompositeInvocationHandlerImpl (com.sun.corba.se.spi.orbutil.proxy)
hashCode:-1, $Proxy0 (com.sun.proxy)
hash:338, HashMap (java.util)
put:611, HashMap (java.util)
add:219, HashSet (java.util)
addCurrentElementToCollection:99, CollectionConverter (com.thoughtworks.xstream.converters.collections)
populateCollection:91, CollectionConverter (com.thoughtworks.xstream.converters.collections)
populateCollection:85, CollectionConverter (com.thoughtworks.xstream.converters.collections)
unmarshal:80, CollectionConverter (com.thoughtworks.xstream.converters.collections)
convert:72, TreeUnmarshaller (com.thoughtworks.xstream.core)
convert:72, AbstractReferenceUnmarshaller (com.thoughtworks.xstream.core)
convertAnother:66, TreeUnmarshaller (com.thoughtworks.xstream.core)
convertAnother:50, TreeUnmarshaller (com.thoughtworks.xstream.core)
start:134, TreeUnmarshaller (com.thoughtworks.xstream.core)
unmarshal:32, AbstractTreeMarshallingStrategy (com.thoughtworks.xstream.core)
unmarshal:1409, XStream (com.thoughtworks.xstream)
unmarshal:1388, XStream (com.thoughtworks.xstream)
fromXML:1282, XStream (com.thoughtworks.xstream)
main:15, xstreamTest (Deser)
```

### JSON反序列化

心细的朋友可以发现几乎所有的XStream的官方通告中都少不了如下的一句话。

```
Note, this example uses XML, but the attack can be performed for any supported format. e.g. JSON.
```

看了一下XStream的介绍文档，我也没看到除了JSON以外别的supported format，这里我可能错了，有误请帮忙指出。接下来找一下JSON的序列化和反序列化的代码怎么写，根据伟大的CSDN程序员的总结，我们可以得知：

XStream针对JSON格式的数据的处理有两个driver可以提供支持，分别是`JsonHierarchicalStreamDriver`和`JettisonMappedXmlDriver`。

|Serialization (Java Object -&gt; JSON)|Deserialization (JSON -&gt; Java Object)
|------
|JsonHierarchicalStreamDriver|√|×
|JettisonMappedXmlDriver|√|√

所以这里只需要看一下`JettisonMappedXmlDriver`对应的代码怎么写就行。但这里有个小坑，刚开始我用官方的代码和网上的教程都出现`ClassNotFoundException`的报错，这里是因为需要加一下`jettison`的依赖。

```
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.jettison&lt;/groupId&gt;
    &lt;artifactId&gt;jettison&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
&lt;/dependency&gt;
```

然后就是粗暴地抄一下官方的教程代码。

```
else if(p == null &amp;&amp; hsp.isAssignableFrom(o.getClass())){
    p = o;
}
```

第二，为了精确匹配对应的request对象，将输入命令部分从自定义HTTP头字段移入了Cookie字段，这个做法的目的是为了防止在传入数据包的时候经过一些代理设备，这些设备可能会移除一些在它看来无用的HTTP头字段，只留下必要的头字段，已知的一定不会被移除的字段包含了Cookie字段和Host字段，所以写入Cookie应该是最方便的，也是最好读取的。

同时在写入response对象的时候，我修改代码使其可以同时写入body以及Set-Cookie字段，这里不是写入自定义字段的理由和上面说的目的一样。同时写入两个地方也是为了避免一些可能出现的错误和问题。

这里只是简单测试一下回显是否可以成功，我就移除了`java.lang.Runtime`执行代码部分，直接写入unique string证明代码执行无误即可。

### Reference

https://x-stream.github.io/security.html

https://blog.csdn.net/fnmsd/article/details/106709736

https://gist.github.com/fnmsd/2fd47012849f25eb53d703f283679462

https://vulhub.org/#/environments/xstream/CVE-2021-21351/

```
来源：https://xz.aliyun.com/t/12999
```

声明：⽂中所涉及的技术、思路和⼯具仅供以安全为⽬的的学习交流使⽤，任何⼈不得将其⽤于⾮法⽤途以及盈利等⽬的，否则后果⾃⾏承担。**所有渗透都需获取授权**！
