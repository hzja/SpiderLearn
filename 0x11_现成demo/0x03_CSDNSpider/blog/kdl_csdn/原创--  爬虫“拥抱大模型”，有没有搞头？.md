# 原创
：  爬虫“拥抱大模型”，有没有搞头？

# 爬虫“拥抱大模型”，有没有搞头？

### 前言

大模型是当前最热门的研究方向之一，千行百业加速“拥抱大模型”。如今，越来越多的研究机构和企业选择开放大模型的源代码和训练数据，促进了学术界和工业界的合作与交流，推动了技术进步，相关生态越来越好。这也使得，无论体量大小，各公司都有参与的机会，越来越多的大模型开始支持多模态输入和输出，能够处理文本、图像、音频等多种类型的数据。

但是这么多的大模型，谁更胜一筹呢？谁能与爬虫产生更好的反应呢？本文将对各大常见的国内外大语言模型进行对比测试，从数据层面，体现一些直观的信息。

> 
各大模型真实速度测评：https://mp.weixin.qq.com/s/UFji5m3Ji1gvsQXqDTy9NQ


### 大语言模型

大语言模型（Large Language Model, LLM）是一种基于深度学习的人工智能模型，专门用于处理和生成自然语言文本，下文的相关解释源自 GPT-4o：

大语言模型具备高效的语言理解和生成能力，广泛的应用场景，能够处理复杂的语言任务。

不过大语言模型对资源的消耗巨大：

据斯坦福人工智能研究所发布的《2023 年 AI 指数报告》，AI 大语言模型 GPT-3 一次训练的耗电量为 1287 兆瓦时，大概相当于 3000 辆特斯拉电动汽车共同开跑、每辆车跑 20 万英里所耗电量的总和。报告同时提出，AI 大语言模型 GPT-3 一次训练，相当于排放了 552 吨二氧化碳。

弗吉尼亚理工大学研究指出，Meta 公司在 2022 年使用了超过 260 万立方米的水，主要作用是为数据中心提供冷却。

据了解，人工智能大模型 GPT-4 的主要参数是 GPT-3 的 20 倍，计算量是 GPT-3 的 10 倍，能耗也随之大幅增加。

上述仅为数据中心能耗成本，GPU、其他硬件、人力成本等等，花费都是惊人的。据网上数据统计，如果想在 10 天内训练一个千亿规模的大型模型，大约需要花费 1.43 亿美元！

### 常见的大语言模型

#### 国内

**① 百度 - ERNIE Bot（文心一言）**

基于 ERNIE 模型，专注于提供智能对话和问答服务，能够理解和生成高质量的自然语言文本。

**② 腾讯 - Hunyuan（混元）**

腾讯 AI Lab 推出的大语言模型，旨在提供高效、智能的文本生成和理解能力。

**③ 京东 - Lingxi（言犀）**

京东旗下的大语言模型，专注于提升智能对话和自然语言处理能力。

**④ 月之暗面 - kimi**

kimi 模型强调对多种数据类型（如文本、图像、音频等）的处理能力，以实现更广泛的应用场景和更强大的语言理解和生成能力。

**⑤ 阿里 - Tongyi Qianwen（通义千问）**

提供企业级自然语言处理服务，包括智能客服、智能搜索、文本分析和机器翻译等。

**⑥ 华为 - PanGu（盘古）**

大型预训练语言模型，强调对中文的理解和生成能力。

**⑦ 智源研究院 - WuDao（悟道）**

大规模预训练语言模型，参数规模达到 1.75 万亿，适用于多种 NLP 任务。

#### 国外

**① OpenAI - ChatGPT 系列**

基于 Transformer 架构的大规模生成式预训练模型，具备强大的语言理解和生成能力。

**② Google - BERT and T5**

BERT 侧重于双向编码表示，适用于各种 NLP 任务。T5 将所有 NLP 任务转换为文本到文本的形式，具有很高的灵活性。

**③ Microsoft - Turing NLG**

大规模生成式预训练模型，参数规模巨大，具有卓越的文本生成能力。

**④ Facebook - OPT**

开源的大规模预训练语言模型，强调透明性和可解释性。

**⑤ DeepMind - Gopher**

DeepMind 推出的 2800 亿参数的大规模语言模型，在多个基准测试中表现出色。

本文测试的大语言模型为：腾讯元宝、文心一言 3.5、kimi、通义千问 2.5、GPT-4o。

### 常识问题分析

#### Why did Zhou Shuren beat up Lu Xun

经典问题：“鲁迅为什么暴打周树人”，众所周知，鲁迅（本名周树人）曾在文章中自称“鲁迅打周树人”，这是他在自我剖析和自嘲中的一种表达方式，并不是他真的打自己 ￣▽￣。之前这个问题，就存在个别大模型答错的情况：

最近测试，各大模型，在这个问题上都能准确回答了：

但是换个问法，哎嘿，比如用英文，有的大模型可就宕机了 ￣▽￣：

> 
请参阅相关网站了解更多信息，并随时向我提出任何其他问题。


#### 数字 7.11 跟 7.9 比，哪个大

本文测试的国产的大语言模型，这个问题上都能回答准确：

倒是 GPT-4o 出了岔劈：

英文提问结果也是一样：

GPT-4 能回答正确，看来 GPT-3.5、GPT-4o 还是明显弱一些啊：

### 验证码坐标识别

数据采集过程中，可能会碰到各种风控策略。其中，验证码人机验证是较为常见的，点选类验证码需要识别出相应的坐标，碰到这种情况，一般要么自己训练模型，要么对接打码平台。现在也可以将识别工作交给大模型，我们来看看，相同的问法，各家大模型，在识别验证码坐标上的表现。

#### GPT-4o

问题，选出相似的，并给出坐标：

问题，找出鸟的位置：

#### 通义千问

问题，选出相似的，并给出坐标：

问题，找出鸟的位置：

#### Kimi

Kimi 暂时还不能分析图片文件：

#### 文心一言

问题，选出相似的，并给出坐标（说了一堆，不知道在说什么）：

问题，找出鸟的位置：

#### 腾讯元宝

问题，选出相似的，并给出坐标：

问题，找出鸟的位置：

综上所述，在图片识别方面，GPT 还是有着明显的优势，测试结果：GPT-4o &gt; 腾讯元宝 &gt; 通义千问 = 文心一言 &gt; Kimi。

### 代码解混淆

今时不同往日，现在扣算法就会发现，很多网站的关键代码都经过了混淆处理，掩盖了真实的算法逻辑，增大了逆向的难度。常规的处理方法，要么硬跟，要么使用 AST 技术解混淆，相关技术推荐蔡老板的公众号（菜鸟学Python编程）。

能解混淆自然是最好的，整体逻辑会清晰很多。接下来，我们用一段简单的经过 OB 混淆了的代码，交给各大模型，看看他们的处理能力如何。

原代码：

```
function hi() {
  console.log("Hello World!");
}
hi();

```

OB 混淆后：

> 
OB 混淆测试网站：https://www.obfuscator.io


```
(function (_0x3e0fd2, _0x4d9507) {
    var _0x35a832 = _0x49f9, _0x24b53a = _0x3e0fd2();
    while (!![]) {
        try {
            var _0x384e17 = parseInt(_0x35a832(0x70)) / 0x1 + parseInt(_0x35a832(0x74)) / 0x2 * (parseInt(_0x35a832(0x71)) / 0x3) + parseInt(_0x35a832(0x77)) / 0x4 + -parseInt(_0x35a832(0x7b)) / 0x5 * (-parseInt(_0x35a832(0x78)) / 0x6) + parseInt(_0x35a832(0x6f)) / 0x7 * (-parseInt(_0x35a832(0x72)) / 0x8) + -parseInt(_0x35a832(0x79)) / 0x9 * (parseInt(_0x35a832(0x76)) / 0xa) + -parseInt(_0x35a832(0x75)) / 0xb * (parseInt(_0x35a832(0x7a)) / 0xc);
            if (_0x384e17 === _0x4d9507) break; else _0x24b53a['push'](_0x24b53a['shift']());
        } catch (_0x2befb5) {
            _0x24b53a['push'](_0x24b53a['shift']());
        }
    }
}(_0x396e, 0xad666));

function hi() {
    var _0x20619c = _0x49f9;
    console[_0x20619c(0x73)]('Hello\x20World!');
}

function _0x49f9(_0x30b03a, _0x5089e4) {
    var _0x396e7c = _0x396e();
    return _0x49f9 = function (_0x49f929, _0x5aa706) {
        _0x49f929 = _0x49f929 - 0x6f;
        var _0x1df762 = _0x396e7c[_0x49f929];
        return _0x1df762;
    }, _0x49f9(_0x30b03a, _0x5089e4);
}

hi();

function _0x396e() {
    var _0x20721f = ['26vRQjos', '352XPZRnp', '198430jvTVQT', '5553740GCzFmR', '6723558KGzclN', '9lDhkVw', '858180FVJhEP', '5eMHKUA', '5257oBQoZa', '397536fXbNYr', '145083vijLVr', '5504RSNMkb', 'log'];
    _0x396e = function () {
        return _0x20721f;
    };
    return _0x396e();
}

```

#### 腾讯元宝

```
var key = 'abcdefghijklmnopqrstuvwxyz';
function decrypt(str, key) {
  var result = '';
  for (var i = 0; i &lt; str.length; i++) {
    var index = key.indexOf(str[i]);
    result += String.fromCharCode(index + 97);
  }
  return result;
}

(function (_0x3e0fd2, _0x4d9507) {
    var messages = _0x3e0fd2();
    var expression = '1+2 * 3+4+(-1)*5*(-1)*6+(-1)*7*(-1)*8+(-1)*9 * 10+(-1)*11';
    var calculatedValue = eval(expression);

    if (calculatedValue === _0x4d9507) {
        hi();
    } else {
        console['log']('Invalid expression');
    }
}(_0x396e, 0xad666));

function hi() {
    console['log']('Hello World!');
}

function _0x49f9(_0x30b03a, _0x5089e4) {
    var messages = _0x396e();
    return decrypt(_0x30b03a, key);
}

function _0x396e() {
    var encryptedMessages = [
      'afZ_rFsbwj',
      '352XPZRnp',
      '198430jvTVQT',
      '5553740GCzFmR',
      '6723558KGzclN',
      '9lDhkVw',
      '858180FVJhEP',
      '5eMHKUA',
      '5257oBQoZa',
      '397536fXbNYr',
      '145083vijLVr',
      '5504RSNMkb',
      'log'
    ];
    return encryptedMessages;
}

```

混淆解的较为清晰，但是 expression 有误，输出了 `Invalid expression`。

#### 文心一言

```
// 定义一个简单的数组来存储字符串  
var strings = ['26vRQjos', '352XPZRnp', '198430jvTVQT', '5553740GCzFmR', '6723558KGzclN', '9lDhkVw', '858180FVJhEP', '5eMHKUA', '5257oBQoZa', '397536fXbNYr', '145083vijLVr', '5504RSNMkb', 'log'];

// 创建一个辅助函数来从数组中检索字符串  
function getString(index) {
    return strings[index - 0x6f]; // 减去偏移量0x6f  
}

// 定义hi函数，使用辅助函数来输出Hello World  
function hi() {
    console[getString(0x73)]('Hello World!'); // getString(0x73) 相当于 getString(115)，返回 'log'
}

// 调用hi函数  
hi();

```

解混淆后的代码较为简洁，但是偏移量不对，运行会报错：`TypeError: console[getString(...)] is not a function`。

#### 通义千问

```
// 创建一个数组，其中最后一个元素是 "log"
const array = [
    '26vRQjos', '352XPZRnp', '198430jvTVQT', '5553740GCzFmR',
    '6723558KGzclN', '9lDhkVw', '858180FVJhEP', '5eMHKUA',
    '5257oBQoZa', '397536fXbNYr', '145083vijLVr', '5504RSNMkb', 'log'
];

// 创建一个函数，它可以从数组中获取 "log" 并打印 "Hello World!"
function simplifiedHi() {
    const log = array[12]; // 直接获取 "log"
    console[log]('Hello World!');
}

// 调用简化后的 hi 函数
simplifiedHi();

```

可以正常输出 `Hello World!`，且解混淆后的代码较为简洁。

#### Kimi

```
(function (dictionary, expectedValue) {
    var decode = decodeFunction, array = dictionary();
    while (true) {
        try {
            var result = parseInt(decode(0x70)) / 1 + parseInt(decode(0x74)) / 2 * (parseInt(decode(0x71)) / 3) + parseInt(decode(0x77)) / 4 + -parseInt(decode(0x7b)) / 5 * (-parseInt(decode(0x78)) / 6) + parseInt(decode(0x6f)) / 7 * (-parseInt(decode(0x72)) / 8) + -parseInt(decode(0x79)) / 9 * (parseInt(decode(0x76)) / 10) + -parseInt(decode(0x75)) / 11 * (parseInt(decode(0x7a)) / 12);
            if (result === expectedValue) break;
            else array.push(array.shift());
        } catch (e) {
            array.push(array.shift());
        }
    }
})(getDictionary, 0xad666);

function hi() {
    var decode = decodeFunction;
    console[decode(0x73)]('Hello World!');
}

function decodeFunction(index, offset) {
    var dictionary = getDictionary();
    return decodeFunction = function (index, offset) {
        index = index - 0x6f;
        var value = dictionary[index];
        return value;
    }, decodeFunction(index, offset);
}

hi();

function getDictionary() {
    var dictionary = ['26vRQjos', '352XPZRnp', '198430jvTVQT', '5553740GCzFmR', '6723558KGzclN', '9lDhkVw', '858180FVJhEP', '5eMHKUA', '5257oBQoZa', '397536fXbNYr', '145083vijLVr', '5504RSNMkb', 'log'];
    getDictionary = function () {
        return dictionary;
    };
    return getDictionary();
}

```

可以正常输出 `Hello World!`，解混淆后的代码很清晰。

#### GPT-4o

```
(function (_0x3e0fd2, _0x4d9507) {
    var _0x35a832 = _0x49f9, _0x24b53a = _0x3e0fd2();
    while (!![]) {
        try {
            var _0x384e17 = parseInt(_0x35a832(0x70)) / 0x1 + parseInt(_0x35a832(0x74)) / 0x2 * (parseInt(_0x35a832(0x71)) / 0x3) + parseInt(_0x35a832(0x77)) / 0x4 + -parseInt(_0x35a832(0x7b)) / 0x5 * (-parseInt(_0x35a832(0x78)) / 0x6) + parseInt(_0x35a832(0x6f)) / 0x7 * (-parseInt(_0x35a832(0x72)) / 0x8) + -parseInt(_0x35a832(0x79)) / 0x9 * (parseInt(_0x35a832(0x76)) / 0xa) + -parseInt(_0x35a832(0x75)) / 0xb * (parseInt(_0x35a832(0x7a)) / 0xc);
            if (_0x384e17 === _0x4d9507) break; else _0x24b53a['push'](_0x24b53a['shift']());
        } catch (_0x2befb5) {
            _0x24b53a['push'](_0x24b53a['shift']());
        }
    }
}(_0x396e, 0xad666));

function hi() {
    console.log('Hello World!');
}

function _0x49f9(_0x30b03a, _0x5089e4) {
    var _0x396e7c = _0x396e();
    return _0x49f9 = function (_0x49f929, _0x5aa706) {
        _0x49f929 = _0x49f929 - 0x6f;
        var _0x1df762 = _0x396e7c[_0x49f929];
        return _0x1df762;
    }, _0x49f9(_0x30b03a, _0x5089e4);
}

hi();

function _0x396e() {
    var _0x20721f = ['26vRQjos', '352XPZRnp', '198430jvTVQT', '5553740GCzFmR', '6723558KGzclN', '9lDhkVw', '858180FVJhEP', '5eMHKUA', '5257oBQoZa', '397536fXbNYr', '145083vijLVr', '5504RSNMkb', 'log'];
    _0x396e = function () {
        return _0x20721f;
    };
    return _0x396e();
}

```

甚至直接给出了原始代码：

可以看到，几家大模型都能判断出代码目的是 `console.log("Hello World!");`，不过在代码可用性、解混淆能力上，还是有差异的。个人觉得，GPT 的逻辑分析能力更强，通义千问、Kimi 解混淆的可读性更好。测试结果：GPT-4o = 通义千问 = Kimi &gt; 腾讯元宝 = 文心一言。

文心一言的解答速度，明显慢于其他几家。

大模型最多只能解一些简单的混淆，想要处理复杂的混淆代码，还是需要自己学习 AST 相关技术。

### 数据清洗

数据采集过程中，会碰到很多数据存在于 HTML 源码当中，一般需要通过 XPath、正则表达式等，将所需的数据提取出来，有些处理起来会相对痛苦，那么现在，我们能否将这部分工作交给 AI 来清洗呢？接下来测试一下，各大模型能否将以下代码中的 `价格` 提取出来：

```
&lt;div className="l"&gt;
    &lt;div className="lv" onMouseOver="this.className='lv lv1';" onMouseOut="this.className='lv';"&gt;
        &lt;ul className="u1 fontyh"&gt;
            &lt;li className="l1"&gt;
                &lt;div className="bgys"&gt;&lt;span className="s1"&gt;&lt;a href="view1822.html" target="_blank"&gt;查看详情&lt;/a&gt;&lt;/span&gt;无演示&lt;/span&gt;
                &lt;/div&gt;
            &lt;li className="l2"&gt;￥&lt;strong&gt;55.00&lt;/strong&gt;&lt;/li&gt;
            &lt;li className="l3"&gt;&lt;a href="view1822.html" title="xxx" target="_blank"&gt;xxx&lt;/a&gt;&lt;/li&gt;
            &lt;li className="l4"&gt;&lt;a href="../shop/view23.html" target="_blank" class="hui"&gt;xxx工作室&lt;/a&gt;&lt;span&gt;&lt;img src="../img/auto.gif"/&gt;&lt;/span&gt;&lt;/li&gt;
            &lt;li className="l5"&gt;销量&lt;span className="red"&gt;230&lt;/span&gt;笔&lt;/li&gt;

```

#### 腾讯元宝

#### 文心一言

#### 通义千问

#### Kimi

#### GPT-4o

可以看到，对于简单 HTML 源码的数据清洗，几家大模型都可以准确提取出目标内容，不过文心一言给出的代码会又报错 =.=。

Kimi 回答问题有时候需要等待：

当然，没什么是打钱解决不了的问题：

### AI 爬虫框架
